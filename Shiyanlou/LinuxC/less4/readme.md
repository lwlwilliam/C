### Makefile使用

Makefile带来的好处就是——“自动化编译”，一但写好，只需要一个 make 命令，整个工程便可以完全编译，极大的提高了软件的开发效率（特别是对于那些项目较大、文件较多的工程）。

### Makefile简介

读者经常看到一个C程序的项目常常由很多的文件组成，那么，多文件的好处到底在哪里呢？一个最简单也最直接有力的理由就是，这样可以将一个大项目分成多个小的部分，独立开来，利于结构化管理。在修改和维护的时候，优势就更明显了。例如，需要对代码做一点小的改动，如果这个项目所有的代码都在一个文件中，那么就要重新编译所有这些代码，这是很耗时的，不仅效率低，而且维护难度更大。但是，如果是多个不同的文件，那么只需要重新编译这些修改过的文件就行了，而且其他源文件的目标文件都已经存在，没有必要重复编译，这样就会快捷很多。

因此，通过合理有效的划分，将一个项目分解为多个易于处理的文件，是非常明智的做法。多文件的管理方式非常正确的选择。

一个工程中的源文件不计其数，按其类型、功能、模块分别放在若干个目录中。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作(因为makefile就像一个shell脚本一样，可以执行操作系统的命令)。

makefile带来的好处就是——“自动化编译”，一但写好，只需要一个make命令，整个工程完全编译，极大的提高了软件的开发效率。make是一个命令工具，是一个执行makefile中命令的工具程序。

make工具最主要也是最基本的功能就是根据makefile文件中描述的源程序至今的相互关系来完成自动编译、维护多个源文件工程。而makefile文件需要按某种语法进行编写，文件中需要说明如何编译各个源文件并链接生成可执行文件，要求定义源文件之间的依赖关系。


### Makefile基本规则

```
test(目标文件): prog.o code.o(依赖文件列表)
tab(至少一个tab的位置) gcc prog.o code.o -o test(命令)
......
```

一个Makefile文件主要含有一系列的规则，每条规则包含以下内容：一个目录，即make最终需要创建的文件，如可执行文件和目标文件；目标也可以是要执行的动作，如‘clean’；一个或多个依赖文件的列表，通常是编译目标文件所需要的其他文件。之后的一系列命令，是make执行的动作，通常是把指定的相关文件编译成目标文件的编译命令，每个命令占一行，并以tab开头（初学者务必注意：是tab，而不是空格）。


### 使用带宏的Makefile

Makefile还可以定义和使用宏（也称做变量），从而使其更加自动化，更加灵活，在Makefile中定义宏的格式为：`macroname = macrotext`，使用宏的格式为：`$(macroname)`。

```
OBJS = prog.o code.o
CC = gcc
test: $(OBJS)
	$(CC) $(OBJS) -o test
prog.o: prog.c code.h
	$(CC) -c prog.c -o prog.o
code.o: code.c code.h
	$(CC) -c code.c -o code.o
clean:
	rm -rf *.o test
```

如上，OBJS和CC就是宏。
