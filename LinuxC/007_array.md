# 数组

C 编译器并不检查数组的访问越界错误，编译时能顺利通过，所以越界属于运行时错误。

```
int count[4];
int i = 10;
count[i] = 11;
```

有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃。

数组不能互相赋值，例如这样是错误的：

```
int a[5], b[5] = {4, 3, 2, 1};
a = b;
```

**既然不能互相赋值，也就不能用数组作为函数的参数或返回值。**如果写出这样的函数定义：[array.c](src/array.c)。编译器也不会报错，但这样写并
不是传一个数组类型参数的意思。对于数组类型有一条特殊规则：**数组名做右值使用时，自动转换成指向数组首元素的指针**。所以上例的函数调用其实
是传一个指针类型的参数，而不是数组类型的参数。以上提到的`a=b`这个表达式，a 和 b 都是数组类型的变量，但是 b 做右值使用，自动转换成指针类型，
而左边仍是数组类型，所以编译器报的错误信息是`error: imcompatible types in assignment`。

为什么编译器对于这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，通过指针而不是数组名来访问数组时，指针指向数组的什么位置只
有运行时才知道，编译时无法检查是否越界，而运行时检查数组访问越界会影响性能，所以干脆不检查了；理由二，[C99 Retionale]指向，C 语言的设计
精神是：相信每个 C 程序员都是高手，不要阻程序员去干他们需要干的事，高手们使用 count[-1] 这种技巧其实并不少见，不能当作错误。（这操作 666 了）
