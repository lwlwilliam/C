# 函数

main 函数的特殊之处在于执行程序时它自动被系统调用，系统就认准了"main"这个名字，除了名字特殊之外，main 函数和别的函数
没有区别。main 函数的返回值是返回给操作系统看的，因为 main 函数是被操作系统调用的，通常程序执行成功就返回 0，在执行过
程中出错就返回一个非零值。

`$?`是 Shell 中的一个特殊变量，表示上一个运行结束的程序的退出状态。通过 return 不同的值，可以看到在 Shell 中执行结束
后的执行`echo $?`命令输出的退出状态都不同。

关于函数声明、函数定义和函数原型(Prototype)的说明。

```
void threeLine(void);
```

声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。这种只能叫函数声明而不能叫函数定义，只有带函数体的声明
才叫定义。只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，编译器只有见到函数定义才会生成指令，而指令在程序运行
时当然也是要占存储空间的。那么没有函数体的函数声明有什么用呢？它为编译器提供了有用信息，编译器在处理代码的过程中，只有见
到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，然后在碰到函数调时才知道怎么生成相应的指令，
所以函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。

如果在调用函数之前没有声明它会怎么样呢？也可以编译通过。但是在调用函数时并没有声明它，则编译器认为此处隐式声明了该函数，
然后为这个调用生成相应的指令，隐式声明的参数类型和个数根据函数调用代码来确定，隐式声明的返回值类型总是 int。然后编译器
接着往下看，看到函数的定义，发现和先前的隐式声明不一致时就会产生警告。

**注意**：定义变量时可以把同样类型的变量列在一起`int a, b;`，而定义函数参数却不可以，例如下面这样的定义是错误的：

```
void print_time(int hour, minute)
{
	printf("%d:%d\n", hour, minute);
}
```

> TODO: 想想为什么要这样规定？并不是 C 语言的设计者故意找茬，而是不得不这么规定。

C 语言规定了一种特的参数列表格式，例如 printf 的原型是这样的：

```
int printf(const char *format, ...);
```

后面的`...`可以代表 0 个或任意多个参数，这些参数的类型也是不确定的，这称为可变参数(Variable Argument)。

任意函数的定义既规定了返回值的类型，也规定了参数的类型和个数，即使像 printf 这样规定为“不确定”也是一种明确的规定，
调用函数就要严格遵守这些规定，通常我们说函数提供了一个接口(Interface)，调用函数就是使用这个接口，使用的前提是必须
和接口保持一致。

## return 语句

在有返回值的函数中，return 语句的作用是提供整个函数的返回值，并结束当前函数的执行。没有返回值的函数中也可以使用
return 语句，例如当检查到一个错误时提前结束当前函数的执行：

```
#include <math.h>

void print_logarithm(double x)
{
	if (x <= 0.0) {
		printf("Positive numbers only, please.\n");
		return;
	}
	printf("The log of x is %f", log(x));
}
```

这个函数首先检查参数 x 是否大于 0，如果 x 不大于 0 就打印错误提示，然后提前结束函数的执行返回到调用者，只有当 x 大于 0
时才能求对数，在打印了对数结果之后到达函数体的末尾，自然地结束执行返回调用者。

**函数返回一个值相当于定义一个和函数返回值类型相同的临时变量并用 return 后面的表达式来初始化。**

函数的返回值也是按值传递的。

**增量式开发**

要编一个程序求平面上的圆的面积，圆的半径以两个端点的坐标(x1, y1)和(x2, y2)给出。首先分析和分解问题，把大问题分解成小问
题，再对小问题分别求解。这个问题可分为两步：

1.	由两端点坐标求半径的长度，平台上两点间距离的公式是：`distance = sqrt((x2-x1)^2+(y2-y1)^2)`。这个公式可以实现为一个函
	数，参数是两点的坐标，返回值是 distance；

2.	上一步算出的距离是圆的半径，已知圆的半径之后求面积的公式是：`area = pi*radius^2`。这个公式可以实现为一个函数，参数
	是 radius，返回值是 area；

下面用代码来实现以上步骤，[circularArea.c](src/circularArea.c)。

**尽可能复用(Reuse)以前写的代码，避免写重复的代码。**封装就是为了复用，把解决各种小问题的代码封装成函数，在解决一个大问
题时可以用这些函数，在解决第二个大问题时可以复用这些函数。

解决问题的过程是把大的问题分成小的问题，小的问题再分成更小的问题，这个过程在代码中的体现就是：函数是分层设计的。distance
和 area 是两个底层函数，解决一些很小的问题，而 area_point 是一个上层函数，上层函数通过调用底层函数来解决更大的问题，底层
和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被 main 函数调用。

## 递归

```
int factorial(int n)
{
	if (n == 0) {
		return 1;
	} else {
		int recurse = factorial(n - 1);
		int result = n * recurse;
		return result;
	}
}
```

自己直拉或间接调用自己的函数称为递归函数。以上是 factorial 直接调用自己，有时候函数 A 调用函数 B，函数 B 又调用函数 A，
也就是函数 A 间接调用自己，这也是递归函数。以 factorial(3)为例分析一下整个调用过程：

![func2.factorial.png](static/func2.factorial.png)

图中实线箭头表示调用，用虚线箭头表示返回，右边的框表示在调用和返回过程中各函数调用的局部变量的变化情况。

1.	main() 有一个局部变量 result，用一个框表示；

2.	调用 factorial(3) 时要分配参数和局部变量的存储空间，于在 main() 的下面又多了一个框表示 factorial(3) 的参数和局部变量，
	其中 n 已初始化为 3；

3.	factorial(3)又调用 factorial(2)，又要分配 factorial(2) 的参数和局部变量，于是在 main() 和 factorial(3) 下面又多了一个
	框。由于每次调用函数时分配参数和局部变量的存储空间，退出函数时释放它们的存储空间，factorial(3) 和 factorial(2) 是两
	次不同的调用，factorial(3) 的参数 n 和 factorial(2) 的参数 n 各自有各自的空间，虽然它们的变量名都是 n，但运行时却是
	两个不同的 n。并且由于 factorial(2) 和 factorial(3) 还没退出，所以两个函数的参数 n 同时存在，所在在原来的基础上多画
	了一个框；

4.	依次类推，一起递归到基础条件；

随着右边表示存储空间的框的变化过程，随着函数调用的层层深入，存储空间的一端逐渐增长，然后随着函数的层层退出，存储空间的
这一端又逐渐缩短，这是一种具有特定性质的数据结构。它的特性就是只能在某一端增长或缩短，并且每次访问参数和局部变量时只能
访问这一末端的单元，而不能访问内部的单元，比如当 factorial(2) 的存储空间位于末端时，只能访问它的参数和局部变量，而不能
访问 factorial(3) 和 main() 的参数和局部变量。具有这种性质的数据结构称为堆栈或栈(Stack)。每个函数调用的参数和局部变量的
存储空间称为一个栈帧(Stack Frame)。系统为每个程序的运行预留了栈空间，函数调用时就在这个栈空间里分配栈帧，函数返回时就释
放栈帧。

**写递归函数时一定要记得写 Base Case**，否则即使递推关系正确，整个函数也不正确。如果 factorial 函数漏掉了 Base Case：

```
int factorial(int n)
{
	int recurse = factorial(n - 1);
	int result = n * recurse;
	return result;
}
```

那么这个函数就会永远调用下去，直到系统为程序预留的栈空间耗尽程序崩溃（段错误）为止，这称为无穷递归(Infinite recursion)。

**递归和循环是等价的**，用循环能做的事情用递归都能做，反之亦然，事实上有的编程语言（如某些 LISP）只有递归而没有循环。
计算术硬件能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行的高级语言写的程序当然也不可能做到
更多的事情，虽然高级语言有丰富的语法特性，但也只是为做这些事情提供一些方便。那么，为什么计算机是这样设计的？为什么想到计
算机需要具有这几种功能，而不是更多或者更少？这些要归功于早期的计算机科学家，例如 Alan Turing，他们在计算机还没诞生的年代
从数学理论上为计算机的设计指明了方向。可以参考有关计算理论的教材。
