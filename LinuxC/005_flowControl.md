# 流程控制

## 分支

switch 注意事项：

1.	case 后面跟的必须是常量表达式，因为这个值必须是编译时计算出来；

2.	浮点型不能精确比较相等不相等的。因此 C 语言规定 case 后面跟的常量表达式的值必须是可以精确比较的整型或字符型；

3.	进入 case 后如果没有遇到 break 语句就会一直往下执行，后面其它 case 或 default 下面的语句也会被执行到，直到遇到
	break，或者执行到整个 switch 语句块的末尾；

switch 不是必不可缺的，但是有时候会使代码更清晰；另一方面，有时候编译器会对 switch 语句进行整体优化，使它比等价的
if/else 语句所生成的目标代码效率更高。

## 循环

递归调用[003_function.md](003_function.md)都是在重复做同样一件事，就是把 n 乘到 (n - 1)! 上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n 的
值不一样），这种每次都有点区别的重复工作称为迭代(Interation)。虽然迭代用递归来做就够了，但 C 语言提供了循环语句使迭代
程序写起来更方便，例如 factorial 用 while 语句可以写成：

```
int factorial(int n)
{
	int result = 1;
	while (n > 0) {
		result = result * n;
		n = n - 1;
	}
	return result;
}
```

变量 result 在这个循环中的作用是累加器(Accumulator)，把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结
果。变量 n 是循环变量(Loop Variable)。

递归能解决的问题用循环也能解决，但解决问题的思路不一样。用递归解决这个问题靠的是递推关系`n!=n*(n-1)!，用循环解决这个
问题则更像是把这个公式展开了：`n!=n*(n-1)*(n-2)*...*3*2*1。此外，在整个递归调用过程中，虽然分配和释放了很多变量，但是
所有的变量都只在初始化时赋值，没有任何变量的值发生过改变，而上面的循环程序则是通过对 n 和 result 这两个变量多次赋值来
达到同样目的的。前一种思路称为**函数式编程(Functional Programming)，后一种思路称为命令式编程(Imperative Programming)。
函数式编程的“函数”类似于数学函数的概念。

正如递归函数如果写得不小心就会变成无穷递归一样，循环如果写得不小心就会变成无限循环(Infinite Loop)或者叫死循环。如果
while 语句的控制表达式永远为真就是一个死循环，例如`while(1){...}`。

[prime.c](src/prime.c)

其实以上代码判断素数，没有必要从 2 一直检查到 n - 1，只需要从 2 检查到 sqrt(n)。

## goto

break 只能跳出最内层的循环，如果在嵌套循环中遇到某个错误条件需要立即跳到循环之外的某个地方做出错处理，就可以用 goto 语句。

```
for (...) {
	for (...) {
		...
		if (condition) {
			goto error;
		}
	}
}
error:
	statement;
```

这里的`error:`叫做标号(Label)。goto 语句过于强大，从程序中的任何地方都可以无条件跳转到任何地方，只要给那个地方起个标号
就行，唯一的限制是 goto 只能跳到同一个函数的某个标号处，而不能跳到别的函数里。所以，**滥用 goto 语句会使程序的控制流程
非常复杂，可读性很差**。goto 语句不是必须存在的，显然可以用别的办法替代，比如以上代码可以改写为：

```
int cond = 0;
for (...) {
	for (...) {
		...
		if (condition) {
			cond = 1;
			break;
		}
	}
	if (cond) {
		break;
	}
}
```

通常 goto 语句只用于在函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），函数中任何地方出现错
误条件都可以立即跳到函数末尾，处理完之后函数返回。
