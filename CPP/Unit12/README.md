### 存储类别、链接和内存管理

> 存储类别

从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为**对象(object)**。
对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。

可以用 **存储期(storage duration)** 描述对象，所谓存储期是指对象中内存中保留了多长时间。
标识符用于访问对象，可以用 **作用域(scope)** 和 **链接(linkage)** 描述标识符，
标识符的作用域和链接表明了程序的哪些部分可以使用它。

>> 作用域

**作用域** 描述程序中可访问标识符的区域。一个 C 变量的作用域可以是`块作用域、函数作用域、函数原型作用域或文件作用域`。

**块** 是用一对花括号括起来的代码区域。例如，整个函数体是一个块，函数中的做生意复合语句也是一个块。
定义在块中的变量具有 **块作用域(block scope)**，块作用域变量的可见范围是从定义处到包含该定义的块的末尾。
另外，虽然函数的形式参数声明在函数的左花括号之前，但是它们也具有块作用域，属于函数体这个块。

以前，具有块作用域的变量都必须声明有块的开头。C99 标准放宽了这一限制，允许在块中的任意位置声明变量。
因此，对于 for 的循环头，现在可以这样写：

```
for (int i = 0; i < 10; i ++) {
    printf("A C99 feature: i = %d", i);
}
```

为适应这个新特性，C99 把块的概念扩展到包括 for 循环、while 循环、do while 循环和 if 语句所控制的代码，
即使这些代码没有用花括号括起来，也算是块的一部分。所以，上面 for 循环中的变量 i 被视为 for 循环块的一部分，
它的作用域仅限于 for 循环。一旦程序离开 for 循环，就不能再访问 i。

**函数作用域(function scope)** 仅用于 goto 语句的标签。这意味着即使一个标签首次出现在函数的内层块中，
它的作用域也延伸至整个函数。

**函数原型作用域(function prototype scope)** 用于函数原型中的形参名（变量名），如下所示：

```
int mighty(int mouse, double large);
```

函数原型作用域的范围是从形参定义处到原型声明结束。这意味着，编译器在处理函数原型中的形参时只关心它的类型，
而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。
只有在变长数组中，形参名才有用：

```
void use_a_VLA(int n, int m, ar[n][m]);
```

变量的定义在函数的外面，具有 **文件作用域(file scope)**。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。
由于这样的变量可用于多个函数，所以文件作用域变量也称为 **全局变量(global variable)**。

**注意 翻译单元和文件**：C 预处理实际上是用包含的头文件内容替换`#include`指令。所以，编译器源代码文件和所有的头文件都
看成是一个包含信息的单独文件。这个文件被称为 **翻译单元(translation unit)**。描述一个具有文件作用域的变量时，
它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。
每个翻译单元均对应一个源代码文件和它所包含的文件。

>> 链接

C 变量有 3 种链接属性：`外部链接、内部链接或无链接`。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。
这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。
外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符`static`。

```
int giants = 5;          // 文件作用域，外部链接
static int dodgers = 3;  // 文件作用域，内部链接

int main()
{
    ...
}
...
```

该文件和同一程序的其他文件都可以使用变量 giants。而变量 dodgers 属文件私有，该文件中的任意函数都可使用它。

>> 存储期

作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。
C 对象有 4 种存储期：`静态存储期、线程存储期、自动存储期、动态分配存储期`。

如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域亦是具有静态存储期。注意，对于文件作用域变量，
关键字`static`表明了其链接属性，而非存储期。以`static`声明的文件作用域具有内部链接。但是无论是内部链接还是外部链接，
所有的文件作用域变量都具有静态存储期。

线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。
以关键字`_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份。

块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存：当退出这个块时，释放刚才为变量分配的内存。
这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，
其变量占用的内存可用于储存下一个被调用函数的变量。

变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

然而，块作用域变量也能具有静态存储期。为创建这样的变量，要把变量声明在块中，且在声明前面加上关键字`static`：

```
void more(int number)
{
    int index;
    static int ct = 0;
    ...
    return 0;
}
```

这里，变量 ct 储存在静态内存中，它从程序被载入到程序结束期间都存在。但是它的作用域定义在 more() 函数块中。
只有在执行该函数时，程序才能使用 ct 访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，
例如通过指针形参或返回值）。

##### 5 种存储类别：

| 存储类别     | 存储期 | 作用域  | 链接 | 声明方式                    |
| :--         | :--   | :--    | :--  | :--                        |
| 自动        | 自动   | 块     | 无    | 块内                       |
| 寄存器      | 自动   | 块     | 无    | 块内，使用关键字 register    |
| 静态外部链接 | 静态   | 文件   | 外部  | 所有函数外                   |
| 静态内部链接 | 静态   | 文件   | 内部  | 所有函数外，使用关键字 static |
| 静态无链接   | 静态   | 块     | 无   | 块内，使用关键字 static       |


>> 自动变量

属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。
可以使用关键字`auto`，如下所示：

```
int main()
{
    auto int plox;
}
```

关键字`auto`是 **存储类别说明符(storage-class specifier)**。

变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。
原来该亦是占用的内存位置现在可做他用。

>>> 没有花括号的块

C99 的一个特性：作为循环或 if 语句的一部分，即使不使用花括号({})，也是一个块。更完整地说，
整个循环是它所在块的 **子块(sub-block)**，循环体是整个循环块的子块。与此类似，if 语句是一个块，
与其相关联的子语句是 if 语句的子块。

**注意 支持 C99 和 C11**：有些编译器并不支持 C99/C11 的这些作用域规则（Microsoft Visual Studio 2012 就是其中之一）。
有些编译会提供激活这些规则的选项，但是要用`-std=c99`选项：`gcc -std=c99 test.c`。

>>> 自动变量的初始化

自动变量不会初始化，除非显式初始化它。考虑下面的声明：

```
int main()
{
    int repid;
    int tents = 5;
}
```

tents 变量被初始化为 5，但是 repid 变量的值是之前占用分配给 repid 的空间中的任意值（如果有的话），别指望这个值是 0。

>> 寄存器变量

变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在 CPU 的寄存器中，或者概括地说，储存在最快的可用内存中。
与普通变量相比，访问和处理这个变量的速度更快。由于寄存器亦是储存在寄存器而非内存中，所以无法获取寄存器变量的地址。
绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储类别说明符`register`便可声明寄存器变量：

```
int main()
{
    register int quick;
}
```

刚才说"如果幸运的话"，是因为声明变量为`register`类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，
或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。

可声明为`register`的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存 double 类型的值。

>> 块作用域的静态变量

**静态变量(static variable)**：静态的意思是该亦是在内存中原地不动，并不是指值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。
静态变量只在编译时被初始化一次。如果未显式初始化静态变量，它们会被初始化为 0。

下面两个声明很相似：

```
void trystat(void)
{
    int fade = 1;
    static int stay = 1;

    printf("fade = %d and stay = %d\n", fade ++, stay ++);
}
```

第 1 条声明确实是 trystat() 函数的一部分，每次调用该函数时都会执行这条声明。这是运行时行为。第 2 条声明实际上并不是 trystat() 函数的一部分。
如果逐步高度该程序会发现，程序似乎跳过了这条声明。因为静态变量和外部变量在程序被载入内存时已执行完毕。把这条声明放在 trystat() 函数中是为了告诉
编译器只有 trystat() 函数才能看到该变量。这条声明并未在运行时执行。**不能在函数的形参中使用 static**。

>> 外部链接的静态变量

外部链接的静态亦是具有文件作用域、外部链接和静态存储期。该类别有时称为 **外部存储类别(external storage class)**，
属于该类别的变量称为 **外部变量(external variable)**。把变量的定义性声明(defining declaration)放在所有函数的外面便创建了外部变量。
当然，为了指出该函数使用了外部变量，可以在函数中用关键字`extern`再次声明。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，
则必须用`extern`在该文件中声明该变量。如下所示：

```
int Errupt;              /* 外部定义的变量 */
double Up[100];          /* 外部定义的变量 */
extern char Coal;        /* 如果 Coal 被定义在另一个文件，则必须这样声明 */

void next(void);
int main()
{
    extern int Errupt;   /* 可选的声明 */
    extern double Up[];  /* 可选的声明 */
    ...
}

void next(void)
{
    ...
}
```

注意，在 main() 中声明 Up 数组时（这是可选的声明）不用指明数组大小，因为第 1 次声明已经提供了数组大小信息。
main() 中的两条 extern 声明完全可以省略，因为外部变量具有文件作用域，所以 Errupt 和 Up 从声明处到文件结尾都可见。
它们出现在那里，仅为了说明 main() 函数要使用这两个变量。

外部变量具有静态存储期。

>>> 初始化外部变量

外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为 0。
这一原则也适用于外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化文件作用域变量：

```
int x = 10;                // 没问题，10 是常量
int y = 3 + 20;            // 没问题，用于初始化的是常量表达式
size_t z = sizeof(int);    // 没问题，用于初始化的是常量表达式（只要不是变长数组，sizeof 表达式可被视为常量表达式）
int x2 = 2 * x;            // 不行，x 是变量
```

>>> 使用外部变量

>>> 外部名称

C99 和 C11 标准都要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符。这修订了以前的标准，
即编译器识别局部标识符前 31 个字符和外部标识符前 6 个字符。

>>> 定义和声明

下面进一步介绍定义变量和声明变量的区别。考虑下面的例子：

```
int tern = 1;  // tern 被定义
int main()
{
    extern int tern;  // 使用在别处定义的 tern
}
```

这里，tern 被声明了两次。第 1 次声明为变量预留了存储空间，该声明构成了变量的定义。
第 2 次声明只告诉编译器使用之前已创建的 tern 变量，所以这不是定义。
第 1 次声明被称为 **定义式声明(defining declaration)**，第 2 次声明被称为 **引用式声明(referencing declaration)**。
关键字 extern 表明该声明不是定义，因为它指示编译器去别处查询其定义。

假设这样写：

```
extern int tern;
int main()
{
    
}
```

编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该声明并不会引起分配存储空间。
因此，不要用关键字 extern 创建外部定义，只用它来引用现有的外部定义。

外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的代码：

```
// file_one.c
char permis = 'N';
...
// file_two.c
extern char permis = 'Y';  // 错误
```

file_two 中的声明是错误的，因为 file_one.c 中的定义式声明已经创建并初始化了 permis。


>> 内部链接的静态变量

该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部，用存储类别说明符 static 定义的变量具有这种存储类别：

```
static int svil = 1;  // 静态变量，内部链接
int main()
{

}
```

可以叫 **内部链接的静态变量(static variable with internal linkage)**。普通的外部变量可用于同一程序中任意文件中的函数，
但是内部链接的静态变量只能用于同一文件中的函数。考虑下面的代码：

```
int traveler = 1;         // 外部链接
static int stayhome = 1;  // 内部链接

int main()
{
    extern int traveler;  // 使用定义在别处的 traveler
    extern int stayhome;  // 使用定义在别处的 stayhome
    ...
}
```

对于该程序所在的翻译单元，traveler 和 stayhome 都具有文件作用域，但是只有 traveler 可用于其他翻译单元。

>> 多文件

只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。

注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用 extern 关键字）。
也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，
其他文件在用 extern 声明之前不能直接使用它。

>> 存储类别说明符

关键字 static 和 extern 的含义取决于上下文。C 语言有 6 个关键字作为存储类别说明符：
1. auto
2. register
3. static
4. extern
5. _Thread_local
6. typedef

typedef 关键字与任何内存存储无关，把它归于此类有一些语法上的原因。
尤其是，在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以这意味着不能使用多个存储类别说明符作为 typedef 的一部分。
唯一例外的是 _Thread_local，它可以和 static 或 extern 一起使用。

auto 说明符表明变量是自动存储期，只能用于块作用域的变量声明中。使用 auto 主要是为了明确表达要使用与外部变量同名的局部变量的意图。

register 说明符也只用于块作用域的变量，请求最快速度访问该变量。同时，保护该变量地址不被获取。

static 说明符创建的对象具有静态存储期，载入程序时创建对象。如果用于文件作用域声明，作用域受限于该文件。
如果用于块作用域声明，作用域受限于该块。

extern 说明符表明声明的变量定义在别处。

>> 存储类别和函数

函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了第 3 种类别——内联函数。
外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件。假设一个文件中包含了以下函数原型：

```
double gamma(double);  // 该函数默认为外部函数
static double beta(int, int);
extern double delta(double, int);
```

在同一程序中，其他文件中的函数可以调用 gamma() 和 delta()，但是不能调用 beta()，
因为以 static 存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题。
通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。
除非使用 static 关键字，否则一般函数声明都默认为 extern。

>> 存储类别的选择

默认类别就是自动存储类别。

保护性程序设计的黄金法则是："按需知道"原则。尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。


> 随机数函数和静态变量

来看一个使用内部链接的静态变量的函数：随机数函数。ANSI C 库提供了 rand() 函数生成随机数。
生成随机数有多种算法，ANSI C 允许 C 实现针对特定机器使用最佳算法。然而，ANSI C 标准还提供了一个可移植的标准算法，
在不同系统中生成相同的随机数。实际上 rand() 是"伪随机数生成器"，意思是可预测生成数字的实际序列。
但是，数字在其取值范围内均匀分布。

> 掷骰子

**TODO**

> 分配内存：malloc() 和 free()

前面讨论的存储类别有一个共同之处：在确定用哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。
然而，还有更灵活的选择，即用库函数分配和管理内存。

malloc() 接受一个参数：所需的内存字节数。malloc() 函数会找到合适的空闲内存块，这样的内存是匿名的。
也就是说，malloc() 分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。

```
double* ptd;
ptd = (double*) malloc(30 * sizeof(double));
```

从 ANSI 标准开始，C 使用一个新的类型：指向 void 的指针。该类型相当于一个"通用指针"。malloc() 函数可用于返回指向数组的指针、
指向结构的指针等，所以通常该函数的返回值会被强制转换为区配的类型。在 ANSI 中，应该坚持使用强制类型转换，提高代码的可读性。

malloc() 可能分配不到所需的内存。在这种情况下，该函数返回空指针。free() 只释放其参数所指导的内存块。
一些操作系统在程序结束时会自动释放动态分配的内存，但是有些系统不会。为保险起见，请使用 free()，不要依赖操作系统来清理。

>> free() 的重要性

静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动奕量使用的内存数量在程序执行期间自动增加或减少。
但是动态分配的内存数量只会增加，除非用 free() 进行释放，否则会导致 **内存泄漏**。

>> calloc()

分配内存还可以使用 calloc()，典型用法如下：

```
long* newmem;
newmem = (long*) calloc(100, sizeof(long));
```

和 malloc() 类似，在 ANSI 之前，calloc() 也返回指向 char 的指针；在 ANSI 之后，返回指向 void 的指针。
calloc() 接受两个无符号整数作为参数（ANSI 规定是 size_t 类型）。第 1 个参数是所需的存储单元数量，
第 2 个参数是存储单元的大小（以字节为单位）。在上例中，long 为 4 字节，所以，该代码创建了 100 个 4 字节的存储单元，
总共 400 字节。

calloc() 还有一个特性：它把块中的所有位都设置为 0（注意，在某些硬件系统中，不是把所有位都设置为 0 来表示浮点值 0）。
free() 也可用于释放 calloc() 分配的内存。

>> 动态分配内存和变长数组

变长数组(VLA) 和调用 malloc() 在功能上有些重合。例如，两者都可用于创建在运行时确定大小的数组：

```
int vlamal()
{
    int n;
    int* pi;
    
    scanf("%d", &n);
    pi = (int*) malloc(n * sizeof(int));
    
    int ar[n];  // 变长数组
    
    pi[2] = ar[2] = -5; 
    ...
}
```

不同的是，变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时，变长数组占用的内存空间会被自动释放，不必使用 free()。
另一方面，用 malloc() 创建的数组不必局限在一个函数内访问。

>> 存储类别和动态内存分配

存储类别和动态内存分配有何联系？先看一个理想化模型。可以认为程序把它可用的内存分为 3 部分：一部分供具有外部链接、
内部链接和无链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。

静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，
在程序结束时被销毁。

然而，自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。因此，随着程序调用函数和函数结束，
自动变量所用的内存数量也相应地增加和减少。这部分的内存通常作为栈来处理，这意味着新创建的变量按顺序加入内存，然后以相反的顺序销毁。

动态分配的内存在调用 malloc() 或相关函数时存在，在调用 free() 后释放。这部分的内存由程序员管理，而不是一套规则。
所以内存块可以在一个函数中创建，在另一函数中销毁。正是因为这样，这部分的内存用于动态内存分配会支离破碎。也就是说，
未使用的内存块分散在已使用的内存块之间。另外，使用动态内存通常比使用栈内存慢。

总而言之，程序把静态对象、自动对象和动态分配的对象储存在不同的区域。


> ANSI 类型限定符

**TODO**

