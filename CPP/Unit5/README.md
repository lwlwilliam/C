# 运算符、表达式和语句

C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值的大小、修改变量、逻辑地组合关系等。组织程序是处理数据的另一个方面，让程序
按正确的顺序执行各个步骤。

## 循环简介

[shoes1.c](shoes1.c)

[shoes2.c](shoes2.c)

## 基本运算符

C 用**运算符(operator)**表示算术运算。

### 赋值运算符：=

在 C 语言中，类似这样的语句没有意义（实际上是无效的）：

```
2002 = bmw;
```

因为在这种情况下，2002 被称为**右值(rvalue)**，只能是字面常量。不能给常量赋值，常量本身就是它的值。= 号左侧的项必须是一个变量名。实际上，赋值
运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。概括地说，C 使用**可修改的左值(modifiable lvalue)**标记那些可赋值的实体。

#### 几个术语：数据对象、左值、右值和运算符

赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为**数据对象(data object)**。C 标准只有在提到这个概念时才会用到**对象**
这个术语。**左值(lvalue)**是 C 语言的术语，用于标识特定数据对象的名称或表达式。**右值(rvalue)**指的是能赋值给可修改左值的量，且本身不是左值。

[golf.c](golf.c)

### 加法运算符：+

### 减法运算符：-

### 符号运算符：+ 和 -

```
rocky = -12;
smokey = -rocky;
```

以这种方式使用的负号被称为**一元运算符(unary operator)**。

### 乘法运算符：*

[squares.c](squares.c)

[wheat.c](wheat.c)

### 除法运算符：/

整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。在 C 语言中，整数除法结果的小数部分被丢弃，这一过程被称为**截断(truncation)**。

[divide.c](divide.c)

### 运算符优先级

### 优先级和求值顺序

运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：

```
y = 6 * 12 + 5 * 20;
```

当运算符共享一个运算对象时，优先级决定了求值顺序。如上面语句，12 是`\*`和`+`运算符的运算对象。乘法的优先级比加法高，所在先进行乘法运算。类似
地，5 也是如此。先进行两个乘法运算，再进行加法运算。但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者。

[rules.c](rules.c)

## 其他运算符

C 语言有大约 40 个运算符。

### sizeof 运算符和 size_t 类型

[sizeof.c](sizeof.c)

### 求模运算符：%

[min_sec.c](min_sec.c)

### 递增运算符：++

[add_one.c](add_one.c)

好处：

* 程序更加简洁；

* 生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似；但是，随着 C 编译器越来越智能，这一优势可能会消失。

最后，递增运算符还有一个在某些场合特别有用的特性。

[post_pre.c](post_pre.c)

### 递减运算符

[bottles.c](bottles.c)

### 优先级

递增和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。

### 不要自作聪明

* 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；

* 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符；

## 表达式和语句

### 表达式

**表达式(expression)**由运算符和运算对象组成。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。如下：

```
4
-6
4 + 21
a * (b + c / d) / 20
q = 5 * 2
x = ++q % 3
q > 3
```

C 表达式的一个最重要的特性是，**每个表达式都有一个值**。以上的前几个都很清晰了。但是，赋值运算符(=)表达式的值是什么？这些表达式的值与赋值运
算符左侧变量的值相同。因此，表达式`q = 5 * 2`作为一个整体的值是 10。那么表达式`q > 3`的值是什么？这种关系表达式的值不是 0 就是 1。

### 语句

**语句(statement)**是 C 程序的基本构建块。一条语句相当于一条完整的计算机指令。在 C 中，大部分语句都以分号结尾。因此，`legs = 4`只是一个表达式
（它可能是一个较大表达式的一部分），而`legs = 4;`则是一条语句。最简单的语句是空语句`; // 空语句`。C 把末尾加上一个分号的表达式都看作是一条语句（
即表达式语句），因此，这样写也没问题：

```
8;
3 + 4;
```

但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数：

```
x = 25;
++x;
y = sqrt(x);
```

虽然一条语句（或者至少是一条有用的语句）相当于一条完整的语句，但并不是所有的指令都是语句。

```
x = 6 + (y = 5);
```

该语句中的子表达式`y = 5`是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，
简单语句）。

[addemup.c](addemup.c)

**注意：声明创建了名称和类型，并为其分配内存位置。但是，声明不是表达式语句。**也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也
没有值。

函数表达式语句会引起函数调用。

while 循环中只有一条语句。可以是本例那样的一条语句，不需要花括号括起来；也可以包含多条语句，需要花括号括起来，这种语句是复合语句。while 语句是
一种迭代语句，有时也被称为**结构化语句**。

#### 副作用和序列点

C 语言的**副作用(side effect)**是对数据对象或文件的修改。例如，语句：

```
states = 50;
```

它的副作用是将变量的值设置为 50。这似乎更像是主要目的！但是从语句的角度看，主要目的是对表达式求值。

**序列点(sequence point)**是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C 语言中，语句中的分号标记了一个序列点。意思是，
在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。任何一个完整表达式的结束也是一个序列点。

所谓**完整表达式(full expession)**，就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和 while 循环中的作为测试条件
的表达式，都是完整表达式。

序列点有助于分析后缀递增何时发生。例如：

```
while (guests++ < 10)
	printf("%d \n", guests);
```

表达式`guests++ < 10`是一个完整的表达式，因此该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf() 之前发生副作用（即，递增 guests）。

```
y = (4 + x++) + (6 + x++);
```

表达式`4 + x++`不是一个完整的表达式，所以 C 无法保证 x 在子表达式`4 + x++`求值后立即递增 x。这里，完整表达式是整个赋值表达式语句，分号标记了
序列点。应避免写类似的语句。

### 复合语句（块）

**复合语句(compound statement)**是用花括号括起来的一条或多条语句，复合语句也称为**块(block)**。
