# 位操作

## 二进制数、位和字节

### 二进制整数

通常，1 字节包含 8 位。C 语言用 **字节(byte)** 表示储存系统字符集所需的大小，所以 C 字节可能是 8 位、
9 位、16 位或其他值。不过描述存储器芯片和数据传输率中所用的字节指的是 8 位字节。为了简化，假设 1 字节
是 8 位（计算机界通常用八位组(octet)这个术语特指 8 位字节）。可从左往右给这 8 位分别编号为 7～0。
在 1 字节中，编号为 7 的位被称为 **高阶位(high-order bit)**，编号是 0 的位被称为 **低阶位(low-order bit)**。

128 是 2 的 7 次幂，以此类推。该字节能表示的最大数字是把所有位都设置为 1：11111111。这个二进制的数值是：

```
2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0 = 255
```

而该字节最小的二进制数是 00000000，其值为 0。因此，1 字节可储存 0～255 范围的数字，总共 256 个值。或者，
通过不同的方式解释 **位组合(bit pattern)**，程序可以用 1 字节储存 -128～+127 范围内的整数，总共还是 256 个值。

### 有符号整数

如何表示有符号整数取决于硬件，而不是 C 语言。也许表示有符号数最简单的方式是用 1 位（如，高阶位）储存符号，只剩下 
7 位表示数字本身（假设储存在 1 字节中）。用这种 **符号量(sign-magnitude)** 表示法，10000001 表示 -1，
00000001 表示 1.因此其表示范围是 -127～+127。这种方法的缺点是有两个 0：+0 和 -0，容易混淆，而且用两个位组合来表示
一个值也有些浪费。

**二进制补码(two's-complement)** 方法避免了这个问题，是当今最常有的系统。以 1 字节为例，二进制补码用 1 字节中的
后 7 位表示 0～127，高阶位设置为 0。另外，如果高阶位是 1，表示的值为负。从一个 9 位组合 100000000（256 的二进制组合）
减去一个负数的位组合，结果是该负值的量。例如，假设一个负值的位组合是 10000000， 作为一个无符号字节，该组合表示 128；
作为一个有符号值，该组合表示负值（编码是 7 的位为 1），而且值为 100000000 - 10000000，即（128）。因此，
该数是 -128。类似地，10000001 是 -127，11111111 是 -1。该方法可以表示 -128～+127 范围内的数。

要得到一个二进制补码数的相反数，最简的方法是反转每一位（即 0 变为 1，1 变为 0），然后加 1。

**二进制反码(one's-complement)** 方法是通过反转位组合中的每一位形成一个负数。例如，00000001 是 1，那么 11111110 是 -1。
这种方法也有一个 -0：11111111。该方法能表示 -127～+127 之间的数。

### 二进制浮点数

浮点数分两部分储存：二进制小数和二进制指数。

#### 二进制小数

一个普通的浮点数 0.527，表示如下：`5/10 + 2/100 + 7/1000`。从左往右，各分母都是 10 的递增次幂。在二进制小数中，
使用 2 的幂作为分母，所以二进制小数 .101 表示为：`1/2 + 0/4 + 1/8`，用十进制表示法为：`0.50 + 0.00 + 0.125`，
即是 0.625。

许多分数（如，1/3）不能用十进制表示法精确地表示，与此类似，许多分数也不能用二进制表示法准确地表示。实际上，二进制
表示法只能精确地表示多个 1/2 的幂的和。因此，3/4 和 7/8 可以精确地表示为二进制小数，但是 1/3 和 2/5 却不能。

#### 浮点数表示法

为了在计算机中表示一个浮点数，要留出若干位（因系统而异）储存二进制分数，其他位储存指数。一般而言，数字的实际值是由二进制
小数乘以 2 的指定次幂组成。例如，一个浮点数乘以 4，那么二进制小数不变，其指数乘以 2，二进制分数不变。如果一浮点数乘以
一个不是 2 的幂的数，会改变二进制小数部分，如有必要，也会改变指数部分。


## 其他进制数

计算机界通常使用八进制记数系统和十六进制记数系统。因为 8 和 16 都是 2 的幂，这些系统比十进制系统更接近计算机的二进制系统。

### 八进制

**八进制(octal)** 是指八进制记数系统。每个八进制位对应 3 个二进制位。

### 十六进制

**十六进制(hexadecimal 或 hex)** 是指十六进制记数系统。每个十六进制位都对应一个 4 位的二进制数（即 4 个二进制位）。


## C 按位运算符

C 提供按位逻辑运算符和移位运算符。

### 按位逻辑运算符

4 个按位逻辑运算符都用于整型数据，包括 char。之所以叫 **按位(bitwise)** 运算，是因为这些操作都是针对每一个位进行，不影响它左右两边的位。

#### 二进制反码或按位取反：~

一元运算符`~`把 1 变为 0，把 0 变为 1。如：

```
~(10011010)  // 表达式
(01100101)   // 结果值
```

该运算符不会改变原来的值，但是可以创建一个可以使用或赋值的新值：

```
newval = ~val;
printf("%d", ~val);

// 如需改变 val 的值
val = ~val;
```

#### 按位与：&

二元运算符`&`通过逐位比较两个运算对象，生成一个新值。对于每个位，只有两个对象中相应的位都为 1 时，结果才为 1（从
真/假方面看，只有当两个位都为真时，结果才为真）。如：

```
(10010011) & (00111101)  // 表达式
// 由于两个运算对象编号为 4 和 0 的位都为 1，得
(00010001)  // 结果值
```

C 有一个按位与和赋值结合的运算符：`&=`。以下两条语句的最终结果相同：

```
val &= 0377;
val = val & 0377;
```

#### 按位或：|

二元运算符`|`，通过逐位比较两个运算对象，生成一个新值。对于每个位，如果两个运算对象中相应的位为 1，结果就为 1（从
真/假方面看，如果两个运算对象中相应的一个位为真或两个位都为真，那么结果为真）。如：

```
(10010011) | (00111101)  // 表达式
// 除了编号为 6 的位，这两个运算对象的其他位至少有一个位为 1，得：
(10111111)  // 结果值
```

C 有一个按位或和赋值结合的运算符：`|=`。以下两条语句的最终作用相同：

```
val |= 0377;
val = val | 0377;
```

#### 按位异或

二元运算符`^`逐位比较两个运算对象。对于每个位，如果两个运算对象中相应的位一个为 1（但不是两个为 1），结果为 1（从
真/假方面看，如果两个运算对象中相应的一个位为真且不是两个同为 1，那么结果为真）。因此，对下面表达式求值：

```
(10010011) ^ (00111101)  // 表达式
// 编号为 0 的位都是 1，所以结果为 0，得：
(10101110)  // 结果值
```

C 有一个按位异或和赋值相结合的运算符：`^=`。以下两条语句的最终作用相同：

```
val ^= 0377;
val = val ^ 0377;
```

### 用法：掩码

按位与运算符常用于 **掩码(mask)**。所为掩码指的是一些设置为开(1) 或关(0)的位组合。要明白称其为掩码的原因，先来看
通过 & 把一个量与掩码结合后发生什么情况。例如，假定定义符号常量 MASK 为 2（即，二进制形式为 00000010），只有 1 号
位是 1，其他位都是 0。下面的语句：

```
flags = flags & MASK;
```

把 flags 中除 1 号位以外的所有位都设置为 0。这个过程叫作"使用掩码"，因为掩码中的 0 隐藏了 flags 中相应的位。
可以这样类比：把掩码中的 0 看作是不透明，1 看作是透明。表达式`flags & MASK`相当于用掩码覆盖在 flags 的位组合上，
只有 MASK 为 1 的位才可见。可以使用`flags &= MASK;`简化上述代码。

### 用法：打开位（设置位）

有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台 IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，
必须打开 1 号位，同时保持其他位不变。这种情况可以使用 **按位或** 运算符(|)。

以上节的 flags 和 MASK 为例，下面的语句：

```
flags = flags | MASK;
```

把 flags 的 1 号位设置为 1，且其他位不变。使用`flags |= MASK;`简化上面代码。

### 用法：关闭位（清空位）

和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。假设要关闭变量 flags 中的 1 号位。可以这样做：

```
flags = flags & ~MASK;
```

可以使用`flags &= ~MASK;`简化上述代码。

### 用法：切换位

切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符(^)切换位。

### 用法：检查位的值

有时，需要检查某位的值。例如，flags 中 1 号位是否被设置为 1？这时需要覆盖 flags 中的其他位，只用 1 号位与 MASK 比较：

```
if ((flags & MASK) == MASK) {
    puts("Wow!");
}
```

为了避免信息漏过边界，掩码至少要与其覆盖的值宽度相同。

### 移位运算符

移位运算符向左或向右移动位。

#### 左移：<<

左移运算符(`<<`)将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用 0 填充空出的位置。

```
(10001010) << 2  // 表达式
(00101000)  // 结果值
```

该操作产生了一个新的位值，但是不改变其运算对象。

#### 右移：>>

右移运算符(`>>`)将其左侧运算对象每一位的值向右移动其右侧运算符对象指定的位数。左侧运算对象移出右末端位的值丢失。对于无符号类型，
用 0 填充空出的位置；对于有符号类型，其结果取决于机器。

```
(10001010) >> 2  // 表达式，有符号值
(00100010)       // 有某些系统中的结果值
(10001010) >> 2  // 表达式，有符号值
(11100010)       // 在另一些系统上的结果值
```

以下是无符号值：

```
(10001010) >> 2  // 表达式，无符号值
(00100010)       // 所有系统都得到该结果值
```

该操作不改变其运算对象。

#### 用法：移位运算符

移位运算符针对 2 的幂提供快速有效的乘法和除法：


| 表达式       | 说明                                          |
| :--         | :--                                           |
| number << n | number 乘以 2 的 n 次幂                        |
| number >> n | 如果 number 为非负，则用 number 除以 2 的 n 次幂 |

这些移位运算符类似于在十进制中移动小数点来乘以或除以 10。

移位运算符还可用于从较大单元中提取一些位。

### 编程示例

代码：binbit.c

### 另一个例子

代码：invert4.c(待研读)


## 位字段

操控位的第 2 种方法是 **位字段(bit field)**。位字段是一个 signed int 或 unsigned int 类型变量中的
一组相邻的位(C99 和 C11 新增了 _Bool 类型的位字段)。位字段通过一个结构声明来建立，该结构声明为每个字段
提供标签，并确定该字段的宽度。例如，下面的声明建立了一个 4 个 1 位的字段：

```
struct {
    unsigned int autfd : 1;
    unsigned int bldfc : 1;
    unsigned int undln : 1;
    unsigned int itals : 1;
} prnt;
```

根据该声明，prnt 包含 4 个 1 位的字段。现在，可以通过普通的结构成员运算符(.)单独给这些字段赋值：

```
prnt.itals = 0;
prnt.undln = 1;
```

由于每个字段恰好为 1 位，所以只能为其赋值 1 或 0。

带有位字段的结构提供一种记录设置的方便途径。许多设置（如，字体的粗体或斜体）就是简单的二选一。有时，某些设置
也有多个选择，因此需要多位来表示，这没问题，字段不限制 1 位大小。如下：

```
struct {
    unsigned int code1 : 2;
    unsigned int code2 : 2;
    unsigned int code3 : 8;
} prcode;
```

可以这样赋值：

```
prcode.code1 = 0;
prcode.code2 = 3;
prcode.code3 = 102;
```

但是要确保所赋的值不超出字段可容纳的范围。假如超过了会怎样？会用到下一个位字段类型的存储位置。一个字段不允许跨越两个
字段之间的边界，编译器会自动移动跨界的字段，保持字段的边界对齐。一旦发生这种情况，第 1 个 位字段中会留下一个未命名的
"洞"。可以用未命名的字段宽度"填充"未命名的"洞"。使用一个宽度为 0 的未命字段迫使下一个字段与下一个整数对齐：

```
struct {
    unsigned int field1 : 1;
    unsigned int        : 2;
    unsigned int field2 : 1;
    unsigned int        : 0;
    unsigned int field3 : 1;
} stuff;
```

### 位字段示例

通常，把位字段作为一种更紧凑储存数据的方式。例如，假设要在屏幕上表示一个方框的属性。为简化问题，假设方框具有如下属性：

* 方框是透明的或不透明的；
* 方框的填充色选自以下调色板：黑色、红色、绿色、黄色、蓝色、紫色、青色或白色；
* 边框可见或隐藏；
* 边框颜色与填充色使用相同的调色板；
* 边框可以使用实线、点线或虚线样式；

可以使用单独的变量或全长(full-sized)结构成员来表示每个属性，但是这样做有些浪费位。
一种方案是：一个字节储存方框内部（透明和填充色）的属性，一个字节储存方框边框的属性，每个字节中的空隙用未命名字段填充。

```
struct box_props {
    bool opaque               : 1;
    unsigned int fill_color   : 3;
    unsigned int              : 4;
    bool show_border          : 1;
    unsigned int border_color : 3;
    unsigned int border_style : 2;
    unsigned int              : 2;
};
```

代码：fields.c

