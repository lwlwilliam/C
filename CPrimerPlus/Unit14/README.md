### 结构和其他数据形式

设计程序时，最重要的步骤之一是选择表示数据的方法。在许多情况下，简单变量甚至是数组还不够。
为此，C 提供了 **结构变量(structure variable)** 提高表示数据的能力，以此可以创造新的形式。

> 示例问题：创建图书目录

代码：book.c

程序清单 book.c 中创建的结构有 3 部分，每个部分都称为 **成员(member)** 或 **字段(field)**。
一部分储存书名，一部分储存作者名，一部分储存价格。下面是必须掌握的 3 个技巧：

* 为结构建立一个格式或样式
* 声明一个适合该样式的变量
* 访问结构变量的各个部分

> 建立结构声明

**结构声明(structure declaration)** 描述了一个结构的组织布局。声明类似下面这样：

```
struct book {
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
```

该声明描述了一个由两个字符数组和一个 float 类型变量组成的结构。该声明并未创建实际的数据对象，
只描述了该对象由什么组成。（有时，结构声明也称为模板。）

细节：关键字 struct，它表明在其后的是一个结构，后面是一个可选的 **标记**（该例中是 book），
稍后程序中可以使用该标记引用该结构。所以，在后面的程序中可以这样声明：`struct book library;`。

这把 library 声明为一个使用 book 结构布局的结构变量。

在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用自己的声明来描述。
成员可以是任意一种 C 的数据类型，其至可以是其他结构！右花括号后面的分号是声明所必需的，
表示结构布局定义结束。

结构的标记名是可选的。但是以程序示例中的方式建立结构时（在一处定义结构布局，在另一处
定义实际的结构变量），必须使用标记。


> 定义结构变量

**结构** 有两层含义。一层含义是“结构布局”，结构布局告诉编译器如何表示数据，但是它并未让
编译器为数据 **分配** 空间。下一步是创建一个 **结构变量**，即是结构的另一层含义。
在程序中创建结构变量的一行是：`struct book library`。

在结构变量的声明中，`struct book`所起的作用相当于一般声明中的 int 或 float。例如，
中以定义两个`struct book`类型的变量：`struct book doyle, panshin, *ptbook;`。
从本质上看，book 结构声明创建了一个名为`struct book`的新类型。

就计算机而言，下面的声明：

```
struct book library;

// 相当于以下声明的简化

struct book {
	char title[MAXTITL];
	char author[MAXAUTL];
	float value;
} library;  /* 声明的右花括号后跟变量名 */
```

换言之，声明结构的过程和定义结构变量的过程可以组合成一个步骤。如下所示，组合后的结构声明和
结构变量定义不需要使用结构标记：

```
struct { /* 无结构标记 */
	char title[MAXTITL];
	char author[MAXAUTL];
	float value;
} library;
```

然而，如果打算多次使用结构模板，就要使用带标记的形式。

>> 初始化结构

初始化一个结构变量与初始化数组的语法类似：

```
struct book library = {
	"The Pious Pirate and the Devious Damsel",
	"Renee Vivotte",
	1.95
};
```

>> 访问结构成员

使用结构成员运算符——点(.)访问结构中的成员。例如，library.value 即访问 library 的 value 部分。
本质上，.title、.author 和 .value 的作用相当于book 结构的下标。

>> 结构的初始化器

C99 和 C11 为结构提供了指定初始化器(designated initializer)，其语法与数组的指定初始化器类似。
但是，结构的指定初始化器使用点运算符和成员名标识特定的元素。例如，只初始化 book 结构的 value 成员，
可以这样做：`struct book surprise = { .value = 10.99 };`。可以按照任意顺利使用指定初始化器：

```
struct book gift = {
	.value = 25.99,
	.author = "James Broadfool",
	.title = "Rue for the Toad"
};
```


> 结构数组

代码：manybook.c

**结构和内存**：manybook.c 程序创建了一个内含 100 个结构变量的数组。由于该数组是自动存储类别的对象，
其中的信息被储存在栈(stack)中。如此大的数组需要很大一块内存，这可能会导致一些问题，如果在运行时出现错误，
可能抱怨栈太小或栈溢出，编译器可能使用了一个默认大小的栈，这个栈对于该例而言太小。要修正这个问题，
可以使用编译器选项设置栈大小，或者创建静态或外部数组（这样，编译器就不会把数组放在栈中），又或者减小
数组大小。

>> 声明结构数组

demo: `struct book library[MAXBKS];`

以上代码把 library 声明为一个内含 MAXBKS 个元素的数组。数组的每个元素都是一个 book 类型的数组。

>> 标识结构数组的成员

为了标识结构数组中的成员，可以采用访问单独结构的规则：在结构名后面加一个点运算符，再在点运算符后面写上成员名。
如下所示：

```
library[0].value  // 第 1 个数组元素与 value 相关联
library[4].title  // 第 5 个数组元素与 title 相关联
```

总结一下：

```
library              // 一个 book 结构的数组
library[2]           // 一个数组元素，该元素是 book 结构
library[2].title     // 一个 char 数组（library[2] 的 title 成员）
library[2].title[4]  // 数组中 library[2] 元素的 title 成员的一个字符
```

>> 程序讨论

一个 while 循环读取多个项。该循环的条件测试是：

```
while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
```

表达式`s_gets(library[count].title, MAXTITL)`读取一个字符串作为书名，如果 s_gets() 尝试读取文件结尾后面，
该表达式返回 NULL。表达式`library[count].title[0] != '\0'`判断字符串中的首字符是否空字符（即，该字符串是否空字符串）。
如果在一行开始处用户按下 Enter 键，相当于输入了一个空字符串，循环将结束。程序还检查了图书的数量，以免超出数组大小。
然后，该程序有如下代码：`while (getchar() != '\n') { continue; }`。这段代码弥补了 scanf() 遇到空格和换行符就结束
读取的问题。例如用户可能输入如下信息：`12.50[Enter]`，其传送的字符序列如下：`12.50\n`，scanf() 接受 `12.50`，
但是把`\n`留在输入序列中。如果没有上面的两行清理输入行代码，就会把留在输入序列中的换行符当作空行读入，程序以为用户发送
了停止输入的信息。


> 嵌套结构

有时，在一个结构中包含另一个结构（即嵌套结构）很方便。

代码：friend.c

访问嵌套结构的成员，需要使用两次点运算符。

> 指向结构的指针

就像指向数组的指针比数组本身更容易操控（如，排序问题）一样，指向结构的指针通常比结构本身更容易操控。
在一些早期的 C 实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。
即使能传递一个结构，传递指针通常更有效率。
一些用于表示数据的结构中包含指向其他结构的指针。

代码：friends.c

>> 声明和初始化结构指针

声明结构指针：`struct guy *him;`，语法和其他指针声明一样。指针 him 现在可以指向任意现有的 guy 类
型的结构。例如，如果 barney 是一个 guy 类型的结构，可以这样写：`him = &barney;`。和数组不同的是，
结构名并不是结构的地址，因此要在结构名前面加上 & 运算符。

>> 用指针访问成员

1. 使用`->`运算符：
   如果`him == &barney`，那么`him->income`即是`barney.income`，
   如果`him == &fellow[0]`，那么`him->income`即是`fellow[0].income`，
   换句话说，`->`运算符后面的结构指针和`.`运算符后面的结构名工作方式相同。
2. 以这样的顺序指定结构成员的值：
   如果`him == &fellow[0]`，那么`*him == fellow[0]`，因此，可以做以下替代：
   `fellow[0].income == (*him).income`，
   必须要使用圆括号，因为`.`运算符比`*`运算符的优先级高。
  
总之，如果 him 是指向 guy 类型结构 barney 的指针，下面的关系恒成立：
`barney.income == (*him).income == him->income  // 假设 him == &barney`


> 向函数传递结构的信息

由于一个结构比一个单独的值复杂，以前的 C 实现不允许把结构作为参数传递给函数。当前的实现已经移除了这个限制，
ANSI C 允许把结构作为参数使用。

1. 可以传递结构本身；
2. 可以传递指向结构的指针；
3. 如果只关心结构中的某一部分，也可以传递结构的成员；

>> 传递结构成员

只要结构成员是一个具有单个值的数据类型（即，int 及其相关类型、char、float、double 或指针），便可把它作为
参数传递给接受该特定类型的函数。

代码：funds1.c

>> 传递结构的地址

代码：funds2.c

该程序把地址 &stan 作为参数传递给 sum()，使得指针指向结构 stan。然后通过`->`运算符获取`stan.bankfund`和
`stan.savefund`的值。由于该函数不能改变指针所指向值的内容，所以把 money 声明为一个指向 const 的指针。

>> 传递结构

代码：funds3.c

在调用 sum() 时，编译器根据 funds 模板创建了一个名为 moolah 的自动结构变量。然后，该结构的各成员被初始化为 
stan 结构变量相应成员的值的副本。因此，程序使用原来结构的副本进行计算。而传递指针的程序 funds2.c 使用的是原
始的结构进行计算。

>> 其他结构特性

现在的 C 允许把一个结构赋值给另一个结构，但是数组不能这样做。也就是说，如果 n_data 和 o_data 是相同类型的结构，
可以这样做：`o_data = n_data; // 把一个结构赋值给另一个结构`。这条语句把 n_data 的每个成员的值都赋给 o_data 
的相应成员。即使成员是数组，也能完成赋值。另外，还可以把一个结构初始化为相同类型的另一个结构：

```
struct names right_field = {"Ruthie", "George"};
struct names captain = right_field;  // 把一个结构初始化为另一个结构
```

现在的 C（包括 ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。结构指针也允许这种双向通信，
因此可以选择任一种方法来解决编程问题。通过以下一组示例来演示这两种方法。

代码：names1.c 和 names2.c

>> 结构和结构指针的选择

把指针作为参数有两个优点：无论是以前还是现在的 C 实现都能使用这种方法，而且执行起来很快，只需要传递一个地址。
缺点是无法保护数据。被调用函数中的某些操作可能会意外影响原来结构中的数据。不过，ANSI C 新增的 const 限定符
解决了这个问题。

把结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护了原始数据。另外，代码风格也更清楚。
缺点是较老版本的实现可能无法处理这样的代码，而且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，
而它只使用结构中的一两个成员时特别浪费。

通常，为了追求效率会使用结构指针作为函数参数，如需防止原始数据被意外修改，使用 const 限定符。按值传递结构是处理
小型结构最常用的方法。

>> 结构中的字符数组和字符指针

```
#define LEN 20
struct names {
    char first[LEN];
    char last[LEN];
};

strct pnames {
    char *first;
    char *last;
};
```

以上两种结构声明都可以，但是如果不理解这样做的含义，可能会有麻烦。考虑下面的代码：

```
struct names veep = {"Talia", "Summers"};
struct pnames treas = {"Brad", "Fallingjaw"};
printf("%s and %s\n", veep.first, treas.first);
```

以上代码没问题，也能正常运行，但是思考一下字符串被储存在何处。对于`struct names`类型的
结构变量 veep，以上字符串都储存在结构内部，结构总共要分配 40 字节储存姓名。然而，对于
`struct pnames`类型的结构变量 treas，以上字符串储存在编译器储存常量的地方。结构本身只
储存了两个地址，在我们的系统中共占 16 字节。尤其是，`struct pnames`结构 **不用为字符
串分配任何存储空间**。它使用的是储存在别处的字符串（如，字符串常量或数组中的字符串）。
简而言之，在 pnames 结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。

考虑下面的代码：

```
struct names accountant;
struct pnames attorney;
puts("Enter the last name of your accountant: ");
scanf("%s", accountant.last);
puts("Enter the last name of your attorney: ");
scanf("%s", attorney.last);  // 这里有一个潜在的危险
```

就语法而言，这段代码没问题。但是，用户的输入储存到哪里去了？对于 accountant，储存在 
accountant 结构变量的 last 成员中；对于 attorney，scanf() 把字符串放到 attorney.last 
表示的地址上。由于这是未经初始化的变量，地址可以是任意值，因此程序可以把名放在任何地方。
如果走运，程序没有问题，至少暂时不会出问题，否则这一操作会导致程序崩溃。实际上，如果程序能
正常运行并不是好事，因为这意味着一个未被察觉的危险潜伏在程序中。
