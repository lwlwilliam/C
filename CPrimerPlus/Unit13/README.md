###

> 与文件进行通信

有时，需要程序从文件中读取信息或把信息写入文件。这种程序与文件交互的形式就是文件重定向。这种方法很简单，
但是有一定限制。例如，假设要编写一个交互程序，询问用户书名并把完整的书名列表保存在文件中。
如果使用重定向，应该类拟于：`books > bklist`。

用户的输入被重琮向到 bklist 中。这样做不仅会把不符合要求的文件写入 bklist，而且用户也看不到要回答什么问题。

C 提供了更强大的文件通信方法，可以在程序中打开文件，然后使用特殊的 I/O 函数读取文件中的信息或把信息写入文件。

>> 文件是什么？

**文件(file)** 通常是在磁盘或固态硬盘上的一段已命名的存储区。

C 把文件看作是一系列连续的字节，每个字节都能被单独读取。这与 UNIX 环境中（C 的发源地）的文件结构相对应。
由于其他环境中可能无法完全对应这个模型，C 提供两种文件模式：`文本模式和二进制模式`。

>> 文本模式和二进制模式

首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格式，以及文件的文本模式和二进制模式。

所有文件的内容都以二进制形式（0 或 1）储存。但是，如果文件最初使用二进制编码的字符（例如，ASCII 或 Unicode）
表示文件（就像 C 字符串那样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代表机器语言代码
或数值数据（使用相同的内部表示，假设，用于 long 或 double 类型的值）或图片或音乐编码，该文件就是二进制文件，
其中包含二进制内容。

UNIX 用同一种文件格式处理文本文件和二进制文件的内容。不奇怪，鉴于 C 是作为开发 UNIX 的工具而创建的，
C 和 UNIX 在文本中都使用 \n（换行符）表示换行。UNIX 目录中有一个统计文件大小的计数，程序可使用该计数确定是否读到文件结尾。

为了规范文本文件的处理，C 提供了两种访问文件的途径：`二进制模式和文本模式`。在二进制模式中，程序可以访问文件的每个字节。
而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为 C 模式。
例如，C 程序在 MS-DOS 平台读取文件时，把 \r\n 转换为 \n；写入文件时，把 \n 转换成 \r\n。在其他环境中编写的文本模式
程序也会做类似的转换。如果要编写旧式 Mac 格式、MS-DOS 格式或 UNIX/Linux 格式的文件模式程序，应该使用二进制模式，
这样程序才能确定实际的文件内容并执行相应的动作。

>> I/O 的级别

除了选择文件的模式，大多数情况下，还可以选择 I/O 的两个级别（即处理文件访问的两个级别）。
**底层 I/O(low-level I/O)** 使用操作系统提供的基本 I/O 服务。
**标准高级 I/O(standard high-level)** 使用 C 库的标准包和 stdio.h 头文件定义。
因为无法保证所有的操作系统都使用相同的底层 I/O 模式，C 标准只支持标准 I/O 包。有些实现会提供底层库，
但是 C 标准建立了可移植的 I/O 模式。

>> 标准文件

C 程序会自动打开 3 个文件，它们被称为 **标准输入(standard input)**、**标准输出(standard output)**
和 **标准错误输出(standard error output)**。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的
普通输出设备，通常是显示屏。

通常，标准输入为程序提供输入，程序通常输出到标准输出，标准错误输出提供了一个逻辑上不同的地方来发送错误消息。


> 标准 I/O

与底层 I/O 相比，标准 I/O 包除了可移植以外还有两个好处。
第一，标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题。例如，printf() 把不同形式的数据转换成与终端相适应的字符串输出。
第二，输入和输入都是 **缓冲** 的。也就是说，一次转移一大块信息而不是一字节信息（通常至少 512 字节）。例如，当程序读取文件时，
一块数据被拷贝到缓冲区（一块中介存储区域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字节。缓冲在后台处理，
所以让人有逐字符访问的错觉（如果使用底层 I/O，要自己完成大部分工作）。

>> 检查命令行参数

看 count.c。

argv[0] 是程序名称。
根据 ANSI C 的规定，在最初调用的 main() 中使用 return 与调用 exit() 的效果相同。因此，在 main()，下面的语句：
`return 0;`和下面这条语句的作用相同：`exit(0);`。注意，这里说的是"最初的调用"。如果 main() 在一个递归程序中，
exit() 仍然会终止程序，但是 return 只会把控制权交给上一级的递归，直至最初一级。还有另一个区别：即使在其他函数中
（除 main() 以外）调用 exit 也能结束整个程序。

>> fopen()

继续分析 count.c。
fopen() 第 1 个参数是待打开文件的名称，更确切地说是一个包含该文件名的字符串地址。第 2 个参数是一个字符串，
指定待打开文件的模式。

以下是 fopen() 的模式字符串：

| 模式字符串                                                  | 含义                                                                                                              |
| :--                                                        | :--                                                                                                              |
| "r"                                                        | 以读模式打开文件                                                                                                   |
| "w"                                                        | 以写模式打开文件，把现有文件的长度截为 0，如果文件不存在，则创建一个新文件                                                |
| "a"                                                        | 以写模式打开文件，在现在文件末尾添加内容，如果文件不存在，则创建一个新文件                                                |
| "r+"                                                       | 以更新模式打开文件（即可以读写文件                                                                                   |
| "w+"                                                       | 以更新模式打开文件（即读和写），如果文件存在，则将其长度截为 0；如果文件不存在，则创建一个新文件                             |
| "a+"                                                       | 以更新模式打开文件（即读和写），在现在文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 |
| "rb", "wb", "ab", "ab+", "a+b", "wb+", "w+b", "ab+", "a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件                                                                |
| "wx", "wbx", "w+x", "wb+x"或"w+bx"                         | (C11)类似非 x 模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败                                               |

程序成功打开文件后，fopen() 将返回 **文件指针(file pointer)**，其他 I/O 函数可以使用这个指针指定该文件。
文件指针的类型是指向`FILE`的指针，FILE 是一个定义在 stdio.h 中的派生类型。文件指针并不指向实际的文件，
它指向一个包含文件信息的数据对象，其中包含操作文件的 I/O 函数所用的缓冲区信息。因为标准库中的 I/O 函数使用缓冲区，
所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。
标准 I/O 函数根据这些信息在必要时决定再次填充或清空缓冲区。该数据对象是一个 C 结构。

>> getc() 和 putc()

getc() 和 putc() 函数与 getchar() 和 putchar() 函数类似。所不同的是，要告诉 getc() 和 putc() 函数使用哪一个文件。

putc(ch, stdout) 和 putchar(ch) 作用相同。stdout 作为与标准输出相关联的文件指针，定义在 stdio.h 中。实际上，
putchar() 函数一般通过 putc() 来定义。与此类似，getchar() 与通过使用标准输入的 getc() 来定义。

>> 文件结尾

从文件中读取数据的程序在读到文件结尾时要停止。如何告诉程序已经读到文件结尾？如果 getc() 函数在读取一个字符时发现是文件结尾，
它将返回一个物殊值`EOF`。所以 C 程序只有在读到文件末尾时才会发现文件的结尾。

为了避免读到空文件，应该使用入口条件循环（不是 do while 循环）进行文件输入。鉴于 getc()（和其他 C 输入函数）的设计，
程序应该在进入循环体之前先尝试读取。如下设计：

```
// 设计范例 #1
int ch;  // 用 int 类型的变量储存 EOF
FILE* fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp);
while (ch != EOF) {
    putchar(ch);  // 处理输入
    ch = getc(fp);  // 获取下一个输入
}
```

以上代码可简化为：

```
// 设计范例 #2
int ch;
FILE* fp;
fp = fopen("wacky.txt", "r");
while ((ch = getc(fp)) != EOF) {
    putchar(ch);
}
```

>> fclose()

fclose(fp) 关闭 fp 指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，
fclose() 返回 0，否则返回 EOF：

```
if (fclose(fp) != 0) {
    printf("Error in closing file %s\n", argv[1]);
}
```

如果磁盘已满、移动硬盘被移除或出现 I/O 错误，都会导致调用 fclose() 函数失败。

>> 指向标准文件的指针

stdio.h 头文件把 3 个文件指针与 3 个标准文件相关联，C 程序会自动打开这 3 个标准文件。
标准文件和相关联的文件指针。如下表：

| 标准文件 | 文件指针 | 通常使用的设备 |
| :--     | :--     | :--          |
| 标准输入 | stdin   | 键盘          |
| 标准输出 | stdout  | 显示器        |
| 标准错误 | stderr  | 显示器        |

这些文件指针都是指向 FILE 的指针，所以它们可用作标准 I/O 函数的参数。


> 一个简单的文件压缩程序

看 reducto.c。假设待读取的文件名为 eddy。该文件中包含下面一行内容：`So even Eddy came oven ready.`。
压缩 eddy，待写入的文件名为 eddy.red，执行完程序打开 eddy.red，内容如下：`Send money`。

该程序演示了几个编程技巧。
`fprintf()`和`printf()`类似，但是`fprintf()`第 1 个参数必须是一个文件指针。程序中使用`stderr`指针把错误消息
发送至标准错误，C 标准通常都这么做。

为了构造新的输出文件名，该程序使用`strncpy()`把名称拷贝到数组`name`中。参数`LEN-5`为`.red`后缀和末尾的空字符预留
了空间。调用`strncpy()`后，`name`中的第 1 个空字符在调用`strcat()`函数时，被`.red`的`.`覆盖，生成了`eddy.red`。
程序还检查了是否成功打开名为`eddy.red`的文件。

该程序同时打开了两个文件，所以我们要声明两个`FILE`指针。注意，程序都是单独打开和关闭每个文件。同时打开的文件数量是有限的，
这个限制取决于系统和实现，范围一般是 10 ～ 20。相同的文件指针可以处理不同的文件，前提是这些文件不需要同时打开。


> 文件 I/O：fprintf()、fscanf()、fgets() 和 fputs()

>> fprintf() 和 fscanf()

工作方式与 printf() 和 scanf() 类似。

>> fgets() 和 fputs()


> 随机访问：fseek() 和 ftell()

有了 fseek()，便可把文件看作是数组，在 fopen() 打开的文件中直接移动到任意字节处。

>> fseek() 和 ftell() 的工作原理

fseek() 的第 1 个参数是 FILE 指针，指向待查找的文件，fopen() 应该已打开该文件；第 2 个参数是 **偏移量(offset)**。
该参数表示从起点开始要移动的距离。该参数必须是一个 long 类型的值，可以为正（前移）、负（后移）或 0（保持不动）；第 3 个
参数是模式，该参数确定起始点。根据 ANSI 标准，在 stdio.h 头文件中规定了几个表示模式的 **明示常量(manifest constant)**，
如下表：

| 模式     | 偏移量的起始点  |
| :--      | :--           |
| SEEK_SET | 文件开始处     |
| SEEK_CUR | 当前位置       |
| SEEK_END | 文件末尾       |

可以使用数值 0L、1L、2L 分别表示这 3 种模式。L 后缀表明其值是 long 类型。下面是一些示例：

```
fseek(fp, 0L, SEEK_SET);    // 定位至文件开始处
fseek(fp, 10L, SEEK_SET);   // 定位至文件中的第 10 个字节
fseek(fp, 2L, SEEK_CUR);    // 从文件当前位置前移 2 个字节
fseek(fp, 0L, SEEK_END);    // 定位至文件结尾处
fseek(fp, -10L, SEEK_END);  // 从文件结尾处回退 10 个字节
```

如果一切正常，fseek() 的返回值为 0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为 -1。

ftell() 的返回类型是 long，它返回的是当前的位置。ANSI C 把它定义在 stdio.h 中。在最初实现的 UNIX 中，
ftell() 通过返回距文件开始处的字节数来确定文件的位置。文件的第 1 个字节到文件开始处的距离是 0，以此类推。
ANSI C 规定，该定义适用于以二进制模式打开的文件，以文本模式打开文件的情况不同。
