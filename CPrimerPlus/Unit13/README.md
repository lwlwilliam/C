### 文件输入/输出

> 与文件进行通信

有时，需要程序从文件中读取信息或把信息写入文件。这种程序与文件交互的形式就是文件重定向。这种方法很简单，
但是有一定限制。例如，假设要编写一个交互程序，询问用户书名并把完整的书名列表保存在文件中。
如果使用重定向，应该类拟于：`books > bklist`。

用户的输入被重琮向到 bklist 中。这样做不仅会把不符合要求的文件写入 bklist，而且用户也看不到要回答什么问题。

C 提供了更强大的文件通信方法，可以在程序中打开文件，然后使用特殊的 I/O 函数读取文件中的信息或把信息写入文件。

>> 文件是什么？

**文件(file)** 通常是在磁盘或固态硬盘上的一段已命名的存储区。

C 把文件看作是一系列连续的字节，每个字节都能被单独读取。这与 UNIX 环境中（C 的发源地）的文件结构相对应。
由于其他环境中可能无法完全对应这个模型，C 提供两种文件模式：`文本模式和二进制模式`。

>> 文本模式和二进制模式

首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格式，以及文件的文本模式和二进制模式。

所有文件的内容都以二进制形式（0 或 1）储存。但是，如果文件最初使用二进制编码的字符（例如，ASCII 或 Unicode）
表示文件（就像 C 字符串那样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代表机器语言代码
或数值数据（使用相同的内部表示，假设，用于 long 或 double 类型的值）或图片或音乐编码，该文件就是二进制文件，
其中包含二进制内容。

UNIX 用同一种文件格式处理文本文件和二进制文件的内容。不奇怪，鉴于 C 是作为开发 UNIX 的工具而创建的，
C 和 UNIX 在文本中都使用 \n（换行符）表示换行。UNIX 目录中有一个统计文件大小的计数，程序可使用该计数确定是否读到文件结尾。

为了规范文本文件的处理，C 提供了两种访问文件的途径：`二进制模式和文本模式`。在二进制模式中，程序可以访问文件的每个字节。
而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为 C 模式。
例如，C 程序在 MS-DOS 平台读取文件时，把 \r\n 转换为 \n；写入文件时，把 \n 转换成 \r\n。在其他环境中编写的文本模式
程序也会做类似的转换。如果要编写旧式 Mac 格式、MS-DOS 格式或 UNIX/Linux 格式的文件模式程序，应该使用二进制模式，
这样程序才能确定实际的文件内容并执行相应的动作。

>> I/O 的级别

除了选择文件的模式，大多数情况下，还可以选择 I/O 的两个级别（即处理文件访问的两个级别）。
**底层 I/O(low-level I/O)** 使用操作系统提供的基本 I/O 服务。
**标准高级 I/O(standard high-level)** 使用 C 库的标准包和 stdio.h 头文件定义。
因为无法保证所有的操作系统都使用相同的底层 I/O 模式，C 标准只支持标准 I/O 包。有些实现会提供底层库，
但是 C 标准建立了可移植的 I/O 模式。

>> 标准文件

C 程序会自动打开 3 个文件，它们被称为 **标准输入(standard input)**、**标准输出(standard output)**
和 **标准错误输出(standard error output)**。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的
普通输出设备，通常是显示屏。

通常，标准输入为程序提供输入，程序通常输出到标准输出，标准错误输出提供了一个逻辑上不同的地方来发送错误消息。


> 标准 I/O

与底层 I/O 相比，标准 I/O 包除了可移植以外还有两个好处。
第一，标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题。例如，printf() 把不同形式的数据转换成与终端相适应的字符串输出。
第二，输入和输入都是 **缓冲** 的。也就是说，一次转移一大块信息而不是一字节信息（通常至少 512 字节）。例如，当程序读取文件时，
一块数据被拷贝到缓冲区（一块中介存储区域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字节。缓冲在后台处理，
所以让人有逐字符访问的错觉（如果使用底层 I/O，要自己完成大部分工作）。

>> 检查命令行参数

看 count.c。

argv[0] 是程序名称。
根据 ANSI C 的规定，在最初调用的 main() 中使用 return 与调用 exit() 的效果相同。因此，在 main()，下面的语句：
`return 0;`和下面这条语句的作用相同：`exit(0);`。注意，这里说的是"最初的调用"。如果 main() 在一个递归程序中，
exit() 仍然会终止程序，但是 return 只会把控制权交给上一级的递归，直至最初一级。还有另一个区别：即使在其他函数中
（除 main() 以外）调用 exit 也能结束整个程序。

>> fopen()

继续分析 count.c。
fopen() 第 1 个参数是待打开文件的名称，更确切地说是一个包含该文件名的字符串地址。第 2 个参数是一个字符串，
指定待打开文件的模式。

以下是 fopen() 的模式字符串：

| 模式字符串                                                  | 含义                                                                                                              |
| :--                                                        | :--                                                                                                              |
| "r"                                                        | 以读模式打开文件                                                                                                   |
| "w"                                                        | 以写模式打开文件，把现有文件的长度截为 0，如果文件不存在，则创建一个新文件                                                |
| "a"                                                        | 以写模式打开文件，在现在文件末尾添加内容，如果文件不存在，则创建一个新文件                                                |
| "r+"                                                       | 以更新模式打开文件（即可以读写文件                                                                                   |
| "w+"                                                       | 以更新模式打开文件（即读和写），如果文件存在，则将其长度截为 0；如果文件不存在，则创建一个新文件                             |
| "a+"                                                       | 以更新模式打开文件（即读和写），在现在文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 |
| "rb", "wb", "ab", "ab+", "a+b", "wb+", "w+b", "ab+", "a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件                                                                |
| "wx", "wbx", "w+x", "wb+x"或"w+bx"                         | (C11)类似非 x 模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败                                               |

程序成功打开文件后，fopen() 将返回 **文件指针(file pointer)**，其他 I/O 函数可以使用这个指针指定该文件。
文件指针的类型是指向`FILE`的指针，FILE 是一个定义在 stdio.h 中的派生类型。文件指针并不指向实际的文件，
它指向一个包含文件信息的数据对象，其中包含操作文件的 I/O 函数所用的缓冲区信息。因为标准库中的 I/O 函数使用缓冲区，
所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。
标准 I/O 函数根据这些信息在必要时决定再次填充或清空缓冲区。该数据对象是一个 C 结构。

>> getc() 和 putc()

getc() 和 putc() 函数与 getchar() 和 putchar() 函数类似。所不同的是，要告诉 getc() 和 putc() 函数使用哪一个文件。

putc(ch, stdout) 和 putchar(ch) 作用相同。stdout 作为与标准输出相关联的文件指针，定义在 stdio.h 中。实际上，
putchar() 函数一般通过 putc() 来定义。与此类似，getchar() 与通过使用标准输入的 getc() 来定义。

>> 文件结尾

从文件中读取数据的程序在读到文件结尾时要停止。如何告诉程序已经读到文件结尾？如果 getc() 函数在读取一个字符时发现是文件结尾，
它将返回一个物殊值`EOF`。所以 C 程序只有在读到文件末尾时才会发现文件的结尾。

为了避免读到空文件，应该使用入口条件循环（不是 do while 循环）进行文件输入。鉴于 getc()（和其他 C 输入函数）的设计，
程序应该在进入循环体之前先尝试读取。如下设计：

```
// 设计范例 #1
int ch;  // 用 int 类型的变量储存 EOF
FILE* fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp);
while (ch != EOF) {
    putchar(ch);  // 处理输入
    ch = getc(fp);  // 获取下一个输入
}
```

以上代码可简化为：

```
// 设计范例 #2
int ch;
FILE* fp;
fp = fopen("wacky.txt", "r");
while ((ch = getc(fp)) != EOF) {
    putchar(ch);
}
```

>> fclose()

fclose(fp) 关闭 fp 指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，
fclose() 返回 0，否则返回 EOF：

```
if (fclose(fp) != 0) {
    printf("Error in closing file %s\n", argv[1]);
}
```

如果磁盘已满、移动硬盘被移除或出现 I/O 错误，都会导致调用 fclose() 函数失败。

>> 指向标准文件的指针

stdio.h 头文件把 3 个文件指针与 3 个标准文件相关联，C 程序会自动打开这 3 个标准文件。
标准文件和相关联的文件指针。如下表：

| 标准文件 | 文件指针 | 通常使用的设备 |
| :--     | :--     | :--          |
| 标准输入 | stdin   | 键盘          |
| 标准输出 | stdout  | 显示器        |
| 标准错误 | stderr  | 显示器        |

这些文件指针都是指向 FILE 的指针，所以它们可用作标准 I/O 函数的参数。


> 一个简单的文件压缩程序

看 reducto.c。假设待读取的文件名为 eddy。该文件中包含下面一行内容：`So even Eddy came oven ready.`。
压缩 eddy，待写入的文件名为 eddy.red，执行完程序打开 eddy.red，内容如下：`Send money`。

该程序演示了几个编程技巧。
`fprintf()`和`printf()`类似，但是`fprintf()`第 1 个参数必须是一个文件指针。程序中使用`stderr`指针把错误消息
发送至标准错误，C 标准通常都这么做。

为了构造新的输出文件名，该程序使用`strncpy()`把名称拷贝到数组`name`中。参数`LEN-5`为`.red`后缀和末尾的空字符预留
了空间。调用`strncpy()`后，`name`中的第 1 个空字符在调用`strcat()`函数时，被`.red`的`.`覆盖，生成了`eddy.red`。
程序还检查了是否成功打开名为`eddy.red`的文件。

该程序同时打开了两个文件，所以我们要声明两个`FILE`指针。注意，程序都是单独打开和关闭每个文件。同时打开的文件数量是有限的，
这个限制取决于系统和实现，范围一般是 10 ～ 20。相同的文件指针可以处理不同的文件，前提是这些文件不需要同时打开。


> 文件 I/O：fprintf()、fscanf()、fgets() 和 fputs()

>> fprintf() 和 fscanf()

工作方式与 printf() 和 scanf() 类似。

>> fgets() 和 fputs()


> 随机访问：fseek() 和 ftell()

有了 fseek()，便可把文件看作是数组，在 fopen() 打开的文件中直接移动到任意字节处。

>> fseek() 和 ftell() 的工作原理

fseek() 的第 1 个参数是 FILE 指针，指向待查找的文件，fopen() 应该已打开该文件；第 2 个参数是 **偏移量(offset)**。
该参数表示从起点开始要移动的距离。该参数必须是一个 long 类型的值，可以为正（前移）、负（后移）或 0（保持不动）；第 3 个
参数是模式，该参数确定起始点。根据 ANSI 标准，在 stdio.h 头文件中规定了几个表示模式的 **明示常量(manifest constant)**，
如下表：

| 模式     | 偏移量的起始点  |
| :--      | :--           |
| SEEK_SET | 文件开始处     |
| SEEK_CUR | 当前位置       |
| SEEK_END | 文件末尾       |

可以使用数值 0L、1L、2L 分别表示这 3 种模式。L 后缀表明其值是 long 类型。下面是一些示例：

```
fseek(fp, 0L, SEEK_SET);    // 定位至文件开始处
fseek(fp, 10L, SEEK_SET);   // 定位至文件中的第 10 个字节
fseek(fp, 2L, SEEK_CUR);    // 从文件当前位置前移 2 个字节
fseek(fp, 0L, SEEK_END);    // 定位至文件结尾处
fseek(fp, -10L, SEEK_END);  // 从文件结尾处回退 10 个字节
```

如果一切正常，fseek() 的返回值为 0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为 -1。

ftell() 的返回类型是 long，它返回的是当前的位置。ANSI C 把它定义在 stdio.h 中。在最初实现的 UNIX 中，
ftell() 通过返回距文件开始处的字节数来确定文件的位置。文件的第 1 个字节到文件开始处的距离是 0，以此类推。
ANSI C 规定，该定义适用于以二进制模式打开的文件，以文本模式打开文件的情况不同。

>> 二进制模式和文本模式

UNIX 只有一种文件格式。

>> 可移植性

>> fgetpos() 和 fsetpos()

fseek() 和 ftell() 潜在的问题是，它们都把文件大小限制在 long 类型能表示的范围内。也许 20 亿字节看起来相当大，
但是随着存储设备的容量迅猛增长，文件也越来越大。鉴于此，ANSI 新增了两个处理较大文件的新定位函数：fetpos() 和 fsetpos()。
这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表 file position type，文件定位类型）。
fpos_t 类型不是基本类型，它根据其他类型来定义。fpos_t 类型的变量或数据对象可以在文件中指定一个位置，
它不能是数组类型，除此之外，没有其他限制。

ANSI C 定义了如何使用 fpos_t 类型，fgetpos() 原型如下：`int fgetpos(FILE * restrict stream, fpos_t * restrict pos);`。
调用该函数时，它把 fpos_t 类型的值放在 pos 指向的位置上，该值描述了文件中的一个位置。如果成功，返回 0；如果失败，返回非 0。

fsetpos() 原型如下：`int fsetpos(FILE * stream, const fpos_t * post);`。调用该函数时，使用 pos 指向位置上的 fpos_t
类型值来设置文件指针指向该值指定的位置。如果成功，返回 0；如果失败，返回非 0。


> 标准 I/O 的机理

通常，使用标准 I/O 的 **第 1 步** 是调用 fopen() 打开文件（C 程序会自动打开 3 种标准文件）。fopen() 不仅打开一个文件，
还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen() 返回一个指向该结构的指针，
以便其他函数知道如何找到该结构。假设把该指针赋给一个指针变量 fp，我们说 fopen() "打开一个流"。如果以文本模式打开该文件，
就获得一个文本流；如果以二进制模式打开该文件，就获得一个二进制流。

这个结构通常包含一个`指定流中当前位置的文件位置指示器`。除此之外，它还包含`错误和文件结尾的指示器`、`一个指向缓冲区开始处的指针`、
`一个文件标识符`和一个`计数`（统计实际拷贝进缓冲区的字节数）。

我们主要考虑文件输入。通常，使用标准 I/O 的 **第 2 步** 是调用一个定义在 stdio.h 中的输入函数，如 fscanf()、getc()、
或 fgets()。一调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异。最初调用函数，除了填充缓冲区外，
还要设置 fp 所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节 0 开始。

在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器被设置为指向刚读取字符的下一个字符。
由于 stdio.h 系列的所有输入函数都使用相同的缓冲区，所以调用任何一个函数都将从上一次函数停止调用的位置开始。

当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取
文件中的所有内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是，下一次被调用的输入函数将返回 EOF。


> 其它标准 I/O 函数

ANSI 标准库的标准 I/O 系列有几十个函数。

>> int ungetc(int c, FILE *fp)

int ungetc() 把 c 指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。
例如，假设要读取下一个冒号之前的所有字符，但是不包括冒号本身，可以使用 getchar() 或 getc() 函数读取字符到冒号，
然后使用 ungetc() 把冒号放回输入流中。ANSI C 标准保证每次只会放回一个字符。

>> int fflush()

原型如下：`int fflush(FILE *fp);`

调用 fflush() 引起输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件。这个过程称为 **刷新缓冲区**。
如果 fp 是空指针，所有输出缓冲区都被刷新。只要最近一次操作不是输入操作，就可以用该函数来更新流（任何读写模式）。

>> int setvbuf()

原型如下：`int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);`

setvbuf() 函数创建了一个供标准 I/O 函数替换使用的缓冲区。在打开文件后且未对流进行其他操作之前，调用该函数。
指针 fp 识别待处理的流，buf 指向待使用的存储区。如果 buf 的值不是 NULL，则必须创建一个缓冲区。例如，
声明一个内含 1024 个字符的数组，并传递该数组的地址。然后，如果把 NULL 作为 buf 的值，该函数会为自己分配一个缓冲区。
变量 size 告诉 setvbuf() 数组的大小。mode 的选择如下：_IOFBF 表示完全缓冲（在缓冲区满时刷新）；
_IOLBF 表示行缓冲（在缓冲区满时或 写入一个换行符是）；_IONBF 表示无缓冲。如果操作成功，返回 0，否则返回非 0。

>> 二进制 I/O：fread() 和 fwrite()

>> size_t fwrite()

原型如下：`size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);`

fwrite() 把二进制数据写入文件。指针 ptr 是待写入数据块的地址。size 表示待写入数据块的大小（以字节为单位），
nmemb 表示待写入数据块的数量。fp 是待写入的文件。例如，要保存一个大小为 256 字节的数据对象（如数组），可以这样做：

```
char buffer[256];
fwrite(buffer, 256, 1, fp);
```

以上调用把一块 256 字节的数据从 buffer 写入文件。

另举一例，要保存一个内含 10 个 double 类型值的数组，可以这样做：

```
double earnings[10];
fwrite(earnings, sizeof(double), 10, fp);
```

以上调用把 earnings 数组中的数据写入文件，数据被分成 10 块，每块都是 double 的大小。

注意 fwrite() 原型中的`const void * restrict ptr`声明。fwrite() 的一个问题是，它的第 1 个参数不是固定的类型。
在 ANSI C 函数原型中，这些实际参数都被转换成指向 void 的指针类型，这种指针可作为一种通用类型指针。
fwrite() 返回成功写入项的数量，正常情况下，该返回值就是 nmemb，但如果出现写入错误，返回值会比 nmemb 小。

>> size_t fread()

原型如下：`size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);`

fread() 接受的参数和 fwrite() 相同。在 fread() 中，ptr 是待读取文件数据在内存中的地址，fp 指定待读取的文件
数据在内存中的地址，fp 指定待读取的文件。例如，要恢复上例中保存的内含 10 个 double 类型值的数组，可以这样做：

```
double earnings[10];
fread(earnings, sizeof (double), 10, fp);
```

该调用把 10 个 double 大小的值拷贝进 earnings 数组中。fread() 返回成功读取项的数量。正常情况下，该返回值就是 nmemb，
但如果出现读取错误或读到文件结尾，该返回值就会比 nmemb 小。

>> int feof(FILE *fp) 和 int ferror(FILE *fp)

如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。然而，出现读取错误时，函数也会返回 EOF。feof() 和 ferror()
用于区分这两种情况。当上一次输入调用检测到文件结尾时，feof() 返回一个非零值，否则返回 0。当读或写出现错误，ferror()
返回一个非零值，否则返回 0。

>> 用二进制 I/O 进行随机访问

随机访问是用二进制 I/O 写入二进制文件最常用的方式。