## 高级数据表示

工具是将要的，真正的挑战是设计和创建一个项目。通常程序开发最重要的部分是找到程序中表示数据的好方法。正确地表示数据可以更容易地编写程序其
余部分。找出正确的数据表示不仅仅是选择一种数据类型，还要考虑必须进行哪些操作。也就是说，必须确定如何储存数据，并且为数据类型定义有效的操
作。C 语言为它的基本类型都定义了有效的操作。但是，要设计数据表示的方案时，可能需要自己定义有效操作。简而言之，设计一种数据类型包括设计如
何储存该数据类型和设计一系列管理该数据的函数。

### 链表

假设要编写一个程序，让用户输入一年内看过的所有电影。要储存每部影片的各种信息，如片名、评级等。建议使用一个结构储存每部电影。一个数组储存
所有电影。为简单起见，规定结构中只有两个成员：片名和评级(0～10)。程序如下：

[films1.c](films1.c)

这样设计程序有点问题。首先，浪费许多空间，因为大部分片名都不会超过 40 个字符；其次，电影数量固定的，同时也会浪费内存；另外，一些编译器对
自动存储类别变量（如 movies）可用的内存数量设置了一个默认的限制，大型的数组可能会超过默认设置的值。可以把数组声明为静态或外部数组，或者
设置编译器使用更大的栈来解决这个问题。但是，这样做不能根本解决问题。

该程序真正的问题是，数据表示太不灵活。程序在编译时所需内存量，其实在运行时确定会更好。要解决这个问题，应该使用动态内存分配来表示数据。

理想的情况是，用户可以不确定地添加数据（或者不断添加数据直到用完内存量），而不是先指定要输入多少项，也不用让程序分配多余的空间。

有一种好的方法。

```cpp
#define TSIZE 45  /* 储存片名的数组大小 */
struct film {
    char title[TSIZE];
    int rating;
    struct film *next;
};
```

每个结构中既包含影片信息，也包含指向下一部影片地址的指针。这种定义是定义**链表(linked list)**的基础，链表中的每一项都包含着在何处能找到
下一项的信息。储存第 1 个结构地址的指针被称为**头指针(head pointer)**。链表中的最后一个结构的 next 成员为 NULL。下图即为链表。

![WX20180301-1540.png](WX20180301-154035.png)

从概念上了解了链表，接着就来实现它。

[films2.c](films2.c)

当然，以上程序还有**不足**。它是在特定方法解决特定问题，并且在需要时才添加相关功能的编程方式通常不是最好的解决方案。另一方面，通常都无法
预料程序要完成的所有任务。随着编程项目的越来越大，一个程序员或编程团队事先计划好一切模式，越来越不现实。很多成功的大型程序都是由成功的小
型程序逐步发展而来。

如果要修改程序，首先应该强调最初的设计，并简化其他细节。以上程序并没有遵循这个原则，它把概念模型和代码细节混在一起。例如，该程序的概念模
型是在一个链表中添加项，但是程序却把一些细节（如，malloc() 和 current->next 指针）放在最明显的位置，没有突出接口。如果程序能以某种方
式强调给链表添加项，并隐藏具体的处理细节（如调用内存管理函数和设置指针）会更好。把用户接口和代码细节分开的程序，更容易理解和更新。

### 抽象数据类型(ADT)

在编程时，应该根据编程问题匹配合适的数据类型。在上面的例子中，已经用 C 语言的功能设计了一种符合程序要求的新数据类型。但是，做法并不系统。
现在要用更系统的方法来定义数据类型。

什么是类型？`类型`特指两类信息：属性和操作。

要定义一个新的数据类型。首先，必须提供储存数据的方法；其次，必须提供操控数据的方法。

计算机科学领域已开发了一种定义新类型的好方法，用 3 个步骤完成从抽象到具体的过程。

1. 提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为**抽象数据类型(ADT)**。

2. 开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C 中，可以提供结构定义和操控该结构的函数原型。这
些作用于用户定义类型的函数相当于作用于 C 基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。

3. 编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。

#### 建立抽象

这里采用一种简化的链表作为抽象数据类型。该类型总结如下：

```
类型名:        简单链表
类型属性:      可以储存一系列项
类型操作:      初始化链表为空
              确定链表为空
              确定链表已满
              确定链表中的项数
              在链表末尾添加项
              遍历链表，处理链表中的项
              清空链表
```

#### 建立接口

[linkedList.h](LinkedList/linkedList.h)

只有 InitializeList()、AddItem() 和 EmptyTheList() 函数要修改链表，因此从技术角度看，这些函数需要一个指针函数。然而，如果某些函数
接受 List 类型的变量作为参数，而其他函数去取接受 List 类型的地址作为参数，用户会很困惑。因此，为了减轻用户的负担，所有的函数均使用指针
参数。

#### 使用接口

目标是：使用这个接口编写程序，但是不必知道具体的实现细节（如，不知道函数的实现细节）。先编写程序的一个伪代码方案。

```
创建一个 List 类型的变量
创建一个 Item 类型的变量
初始化链表为空
当链表未满且有输入时：
    把输入读取到 Item 类型的变量中
    在链表末尾添加项
访问链表中的每个项并显示它们
```

正式程序按照以上伪代码来编写，其中还加入了一些错误检查。该程序还利用了[linkedList.h](LinkedList/linkedList.h)中描述的接口。

[main.c](LinkedList/main.c)

#### 实现接口

[linkedList.c](LinkedList/linkedList.c)

### 队列 ADT

在 C 语言中使用抽象数据类型方法编程包含以下 3 个步骤。

1. 以抽象、通用的方式描述一个类型，包括该类型的操作。

2. 设计一个函数接口表示这个新类型。

3. 编写具体代码实现这个接口。

#### 定义队列抽象数据类型

**队列(queue)**是具有两个特殊属性的链表。第一，新项只能添加到链表的末尾；第二，只能从链表的开头移除项。队列是一种"先进先出"(first in, 
first out，缩写 FIFO)的数据形式，就像排队买票的队伍一样（前提是没有人插队）。以下建立一个非正式的抽象定义：

```
类型名:        队列
类型属性:      可以储存一系列项
类型操作:      初始化队列为空
              确定队列为空
              确定队列已满
              确定队列中的项数
              在队列末尾添加项
              在队列开着删除或恢复项
              清空队列
```

#### 定义一个接口

[queue.h](queue/queue.h)

#### 实现接口函数

[queue.c](queue/queue.c)

#### 测试队列

在重要程序中使用一个新的设计（如，队列包）之前，应该先测试该设计。测试的一种方法是，编写一个小程序。这样的程序称为**驱动程序(driver)**，
其唯一的用途是进行测试。

[main.c](queue/main.c)