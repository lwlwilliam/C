### 高级数据表示

通常，程序开发最重要的部分是找到程序中表示数据的好方法。正确地表示数据可以更容易地编写程序其余部分。
找出正确的数据表示不仅仅是选择一种数据类型，还要考虑必须进行哪些操作。也就是说，必须确定如何储存数据，
并且为数据类型定义有效的操作。例如，C 实现通常把 int 类型和指针类型都储存为整数，但是这两种类型的
有效操作不相同。例如，两个整数可以相乘，但是两个指针不能相乘；可以用`*`运算符解引用指针，但是对整数
这样做毫无意义。C 语言为它的基本类型都定义了有效的操作。但是，当你要设计数据表示的方案时，你可能需要
自己定义有效的操作。在 C 语言中，可以把所需的操作设计成 C 函数来表示。简而言之，设计一种数据类型包括 
**设计如何储存该数据类型和设计一系列管理该数据的函数**。

**算法(algorithm)**，即操控数据的方法。设计数据类型的过程，就是一个把算法和数据表示相匹配的过程。

**抽象数据类型(ADT)** 以面向问题而不是面向语言的方式，把解决问题的方法和数据表示结合起来。

> 研究数据表示

在开始编写代码之前，需要做很多程序设计方面的决定。

**代码：films1.c**，假设要编写一个程序，让用户输入一年内看过的所有电影（包括 DVD 和蓝光光碟）。
要储存每部影片的各种信息，如片名、发行年份、导演、主演、片长、影片的种类（喜剧、科幻、爱情等）、
评级等。建议使用一个结构储存每部电影，一个数组储存一年内看过的电影。为简单起见，现规定结构中只有两个
成员：片名和评级（0～10）。该程序清单演示了一个基本的实现。


> 从数组到链表

使用数组需要事先确定元素的数量，也会导致程序分配多余的空间。这可以调用 malloc() 分配正好足够的空间储存。
但是，如果用户需要输入多组数据，这时候就会有一个麻烦。比较一下，一种方法是调用 malloc() 一次，为所有数
据请求分配足够的空间；另一种方法是调用 malloc() 多次，分别为每一组数据请求分配足够的空间。前者分配的是连
续的内存块，只需要一个单独的指向第一组数据的指针，第 2 种方法的问题是，无法保证每次调用 malloc() 都能分
配到连续的内存块。因此，与第 1 种方法相比，需要储存多个指针，每个指针指向一组数据。当然也可以创建一个大型
的指针数组，并在分配每一组数据时逐个给这些指针赋值，但是不打算这样做，因为假如用不完分配的指针，还是会浪费
空间，而且这样也会有数量的限制。

有一种更好的方法，每次调用 malloc() 为每一组数据分配空间时，也为新指针分配空间。但是，还得需要另一个指针
来跟踪新分配的指针，用于跟踪新指针的指针本身，也需要一个指针来跟踪，以此类推。这时就要重新定义结构才能解决
这个潜在的问题，即每个结构中包含指向 next 结构的指针。然后，当创建新结构时，可以把该结构的地址储存在上一个
结构中。结构如下：

```
#define TSIZE 45
struct film {
    char title[TSIZE];
    int rating;
    struct film *next;
};
```

虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。这种定义是定义 **链表(linked list)** 
的基础，链表中的每一项都包含着在何处能找到下一项的信息。为了表时该结构后面没有其他结构，程序要把 next 成员指针
设置为 NULL。当然，还需要一个单独的指针储存第 1 个结构的地址，该指针被称为 **头指针(head pointer)**。

>> 使用链表

**代码：** films2.c

该程序链表执行两个任务。第 1 个任务是，构造一个链表，把用户输入的数据储存在链表中。第 2 个任务是，显示链表。

>>> 显示链表

显示链表从设置一个指向第 1 个结构的指针（名为 current）开始。由于头指针（名为 head）已经指向链表中的第 1 个
结构，所以可以用下面的代码来完成：

```current = head;```

可以使用以下代码把指针指向下一个结构：

```current = current->next;```

>>> 创建链表

创建链表涉及下面 3 步：
1. 使用 malloc() 为结构分配足够的空间；
2. 储存结构的地址；
3. 把当前信息拷贝到结构中；

如无必要不用创建一个结构，所以程序使用临时存储区（input 数组）获取用户输入的电影名：

```
while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
```

为用户输入分配一个结构空间，并将其地址赋给指针变量 current：

```
current = (struct film *) malloc(sizeof(struct film));
```

链表中的第 1 个结构地址应储存在指针变量 head 中。随后每个结构地址应储存在其前一个结构的 next 成员中。因此，
程序要知道它处理的是否是第 1 个结构。最简单的方法是在程序开始时，把 head 指针初始化为 NULL。然后，程序可以
使用 head 的值进行判断：

```
if (head = NULL)  /* 第 1 个结构 */
    head = current;
else
    prev->next = current;
```

在上面的代码中，指针 prev 指向上一次分配的结构。接下来，必须为结构成员设置合适的值。尤其是，把 next 成员设置
为 NULL，表明当前结构是链表的最后一个结构。还要把 input 数组中的电影名拷贝到 title 成员中，而且要给 rating 
成员提供一个值。如下示：

```
current->next = NULL;
strcpy(current->title, input);
puts("Enter your rating <0-10>: ");
scanf("%d", &current->rating);
```

由于 s_gets() 限制了只能输入 TSIZE - 1 个字符，所以用 strcpy() 把数组中的字符串拷贝到 title 成员很安全。
最后，要为下一次输入做好准备。尤其是，要设置 prev 指向当前结构。因为在用户输入下一部电影且程序为新结构分配空间
后，当前结构将成为新结构的上一个结构，所以程序在循环末尾这样设置该指针：

```prev = current;```

>>> 释放链表

在许多环境中，程序结束时都会自动释放 malloc() 分配的内存。但是，最好还是成对调用 malloc() 和 free()。因此，
程序在清理内存时为每个已分配的结构都调用了 free() 函数：

```
current = head;
while (current != NULL) {
    current = head;
    head = current->next;
    free(current);
}
```

>> 反思

films2.c 程序还有些不足。例如，程序没有检查 malloc() 是否成功请求到内存，也无法删除链表中的项，这些不足可以弥补。
例如，添加代码检查 malloc() 的返回值是否是 NULL。

这种用特定方法解决特定问题，并且在需要时才添加相关功能的编程方式通常不是最好的解决方案。另一方面，通常都无法预料程序
要完成的所有任务。随着编程项目越来越大，一个程序员或编程团队事先计划好一切模式，越来越不现实。很多成功的大型程序都是
由成功的小型程序逐步发展而来。

如果要修改程序，首先应该强调最初的设计，并简化其他细节。程序 films2.c 没有遵循这个原则，它把概念模型和代码细节混在
一起。例如，该程序的概念模型是在一个链表中添加项，但是程序却把一些细节（如，malloc() 和 current->next 指针）放在
最明显的位置，没有突出接口。如果程序能以某种方式强调给链表添加项，并隐藏具体的处理细节（如调用内存管理函数和设置指针）
会更好。把用户接口和代码细节分开的程序，更容易理解和更新。学习下面的内容就可以实现这些目标。


> 抽象数据类型(ADT)

在编程时，应该根据编程问题匹配合适的数据类型。例如，用 int 类型代表你有多少双鞋，用 float 或 double 类型代表每双鞋
的价格。在前面的电影示例中，数据构成了链表，每个链表由电影名（C 字符串）和评级（ 一个 int 类型值）。C 中没有与之匹配
的基本类型，所以定义了一个结构代表单独的项，然后设计了一些方法把一系列结构构成一个链表。本质上，是使用了 C 语言的功能
设计了一种符合程序要求的新数据类型。但是上述的做法并不系统。现在，用更系统的方法来定义数据类型。

什么是类型？**类型** 特指两类信息：属性和操作。例如，int 类型的属性是它代表一个整数值，因此它共享整数的属性。允许对
int 类型进行的算术操作是：改变 int 类型值的符号、进行算术运算。当声明一个 int 类型的变量时，就表明了只能对该变量进行
这些操作。

假设要定义一个新的数据类型。首先，必须提供储存数据的方法，例如设计一个结构。其次，必须提供操控数据的方法。例如，考虑 
films2.c 程序。该程序用链接的结构来储存信息，而且通过代码实现了如何添加和显示信息。尽管如此，该程序并未清楚地表明正
在创建一个新类型。应该如何做？

计算机科学领域已开发了一种定义新类型的好方法，用 3 个步骤完成从抽象到具体的过程。
1. 提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为 
**抽象数据类型(ADT)。
2. 开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C 中，可以提供结构定义和操控
该结构的函数原型。这些作用于用户定义类型的函数相当于作用于 C 基本类型的内置运算符。需要使用该新类型的程序员可以使用这个
接口进行编程。
3. 编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。

>> 建立抽象

从概本上看，以上提及的电影项目所需的是一个项链表。每一项包含电影名和评级。所需的操作是把新项添加到链表末尾和显示链表中的
内容。我们把需要处理这些需求的抽象类型叫作 **链表**。链表具有哪些属性？首先，能储存一系列项。也就是说，链表能储存多个项，
而且这些项以某种方式排列，这样才能描述链表的第 1 项、第 2 项或最后一项。其次，链表类型应该提供一些操作，如在链表添加新项。
下面是链表的一些有用的操作：
* 初始化一个空链表；
* 在链表末尾添加一个新项；
* 确定链表是否为空；
* 确定链表是否已满；
* 确定链表中的项数；
* 访问链表中的每一项执行某些操作，如显示该项；

对该电影项目而言，暂时不需要其他操作。但是一般的链表还应包含以下操作：
* 在链表的任意位置插入一个项；
* 移除链表中的一个项；
* 在链表中检索一个项（不改变链表）；
* 用另一个项替换链表中的一个项；
* 在链表中搜索一个项；

非正式但抽象的链表定义是：链表是一个能储存一系列项且可以对其进行所需操作的数据对象。该定义既未说明链表中可以储存什么项，也未
指定是用数组、结构还是其他数据形式来储存项，而且并未规定用什么方法来实现操作（如，查找链表中元素的个数）。这些细节都留给实现完成。

为了让示例尽量简单，采用一种简化的链表作为抽象数据类型。总结如下：

| 类型名   | 类型属性        | 类型操作                                                                                              |
| :--     | :--            | :--                                                                                                  |
| 简单链表 | 可以储存一系列项 | 初始化链表为空；确定链表为空；确定链表已满；确定链表中的项数；在链表末尾添加项；遍历链表，处理链表中的项；清空链表 |

>> 建立接口

该接口有两个部分。第 1 部分是描述如何表示数据，第 2 部分是描述实现 ADT 操作的函数。接口设计应尽量与 ADT 的描核突中持一致。因此，
应该用某种通用的 Item 类型而不是一些特殊类型，如 int 或 struct film。可以用 typedef 来定义所需的 Item 类型：

```
#define TSIZE 45
struct film {
    char title[TSIZE];
    int rating;
};
typedef struct film Item;
```

然后，就可以在定义的其余部分使用 Item 类型。如果以后需要其他数据形式的链表，可以重新定义 Item 类型，不必更改其余的接口定义。
定义了 Item 之后，现在必须确定如何储存这种类型的项：

```
typedef struct node {
    Item item;
    struct node *next;
} Node;
typedef Node *List;
```

在链表的实现中，每一个链节叫作 **节点(node)**。每个节点包含形成链表内容的信息和指向下一个节点的指针。下面的声明：

```List movies;```

创建了该链表所需类型的指针 movies。

这是否是定义 List 类型的唯一方法？不是。例如，还可以添加一个变量记录项数：

```
typedef struct list
{
	Node *head;
	int size;
} List;
```

现在还是用第 1 种定义。这里着重理解下面的声明创建了一个链表，而不是一个指向节点的指针或一个结构：

```
List movies;
```

movies 代表的确切数据应该是接口层次不可见的实现细节。
例如，程序启动后应把头指针初始化为 NULL。但是，不要使用下面这样的代码：

```
moview = NULL;
```

应该这样初始化：

```
InitializeList(moview);
```

使用该类型的程序员只需知道用 InitializeList() 函数来初始化链表，不必了解 List 类型变量的实现细节。
这是 **数据隐藏** 的一个示例，数据隐藏是一种从编程的更高层次隐藏数据表示细节的艺术。

为了指导用户使用，可以在函数原型前面提供以下注释：

```
/* 操作：初始化一个链表 */
/* 前提条件：plist 指向一个链表 */
/* 后置条件：该链表初始化为空 */

void InitializeList(List * plist);

```

这里要注意 3 点。第 1，注释中的“前提条件”(precondition)是调用该函数前应具备的条件。例如， 需要一个
待初始化的链表。第 2，注释中的“后置条件”(postcondition)是执行完该函数后的情况。第 3，该函数的参数是
一个指向链表的指针，而不是一个链表。所以应该这样调用该函数：

```
InitializeList(&movies);
```
