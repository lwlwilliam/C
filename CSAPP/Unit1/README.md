###

code: hello.c

> 信息就是位 + 上下文

hello 程序的生命周期是从一个 **源程序（或者说源文件）** 开始的，即 hello.c。源程序实际上就是一个由
值 0 和 1 组成的位（又称为比特）序列，8 个位被组织成一组，称为 **字节**。每个字节表示程序中的某些文
本字符。

大部分现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数
值来表示每个字符。hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字
符。像 hello.c 这样只由 ASCII 字符构成的文件称为 **文本文件**，所有其他文件都称为 **二进制文件**。

hello.c 的表示方法说明了一个基本思想：系统中所有的信息，都是由一串比特表示的。区分不同数据对象的唯一
方法是读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、
字符串或者机器指令。


> 程序被其他程序翻译成不同的格式

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行
hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级 **机器语言** 指令。然后这些指令按照一
种称为 **可执行目标程序** 的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为 **可执行目
标文件**。

在 Unix 系统上，从源文件到目标文件的转化是由 **编译器驱动程序** 完成的：

```linux> gcc -o hello hello.c```

在这里，GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过
程可分为四个阶段完成。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了 **编译系统(
compilation system)**。

编译系统：

```
hello.c(源程序[文本]) --预处理器(cpp)--> hello.i(修改了源程序[文本]) --编译器(ccl)--> hello.s(汇编程序[文本])  

--汇编器(as)--> hello.o(可重定位目标程序(二进制)[+ printf.o] --链接器(ld)--> hello(可执行目标程序[二进制])
```

* 预处理阶段。预处理器(cpp)根据以字符`#`开头的命令，修改原始的 C 程序。
* 编译阶段。编译器(ccl)将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序，该程序包
  含函数 main 的含义，如下所示：
    ```
    main:
        subq    $8, %rsp
        mov1    $.LCO, %edi
        call    puts
        mov1    $0, %eax
        addq    $i, %rsp
        ret
    ```  
  定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言非常有用，因为它为不同
  高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一
  样的汇编语言。 
* 汇编阶段。接下来，汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做 **可重定位目标
  程序(relocatable object program)** 的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一
  个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果在文本编辑器打开 hello.o 文件，将看到一
  堆乱码。
* 链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。
  printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到 
  hello.c 程序中。链接器(ld)就负责处理这种合并。结果就得到 hello 文件，它是一个 **可执行目标文件** 
  (或者简称为 **可执行文件**)，可以被加载到内存中，由系统执行。


> 了解编译系统如何工作是大有益处的

对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是有一些重要的原因促使程序
员必须知道编译系统是如何工作的。

* 优化程序性能。为了在 C 程序中做出好的编码选择，确实需要了解一些机器代码以及编译器不同的 C 语句转化为
  机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有
  多大？while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么循环求和的结果放到一个本地变
  量中，会比将其放到一个通过引用传递过来的参数中，运行起来快得多吗？为什么我们只是简单地重新排列一下算术
  表达式中的括号就能让函数运行得更快？
* 理解链接时出现的错误。一些最令人困扰的程序错误往往都与链接器操作有关。