### 信息的表示和处理

现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为 **位(big)**，形成了数字革命的基础。
二值信号能够很容易地被表示、存储和传输。例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针
或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至
数十亿个这样的电路。

孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种 **解释(interpretation)**，即赋予不同的可能
位模式以含义，我们就能够表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使
用标准的字符码，我们能够对文档中的字母和符号进行编码。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会 **溢出(overflow)**。


> 信息存储

大多数计算机使用 8 位的块，或者 **字节(byte)**，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序
将内存视为一个非常大的字节数组，称为 **虚拟内存(virtual memory)**。内存的每个字节都由一个唯一的数字来标识，称为
它的 **地址(address)**，所有可能地址的集合就称为 **虚拟地址空间(virtual address space)**。顾名思义，这个虚拟
地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储(DRAM)、闪存、磁盘存储器、特殊硬件和
操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

>> 十六进制表示法

一个字节由 8 位组成。二进制表示法和十进制表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法
与位模式的互相转化很麻烦。替代方法是以 16 为基数，或者叫做 **十六进制(hexadecimal)** 数，来表示位模式。在 C 语言
中，以 `0x` 或 `0X` 开头的数字常量被认为是十六进制的值。

>> 字数据大小

每台计算机都有一个 **字长(word size)**，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码
的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 ß 位的机器而言，虚拟地址的范围
为 0～2^ß-1，程序最多访问 2^ß 个字节。

>> 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，
多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。某些机器选择在内存中按照从最低有效字节到最高有
效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，
称为 **小端法(little endian)**。后一种规则——最高有效字节在最前面的方式，称为 **大端法(big endian)**。

有时候，字节顺序会成为问题。
首先，在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被改善到大端法机器或者反过来时，
接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保
改送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。
第三种情况是当编写规避正常的类型系统的程序时。在 C 语言中，可以通过使用 **强制类型转换(cast)** 或 **联合(union)** 来
允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，
但是它们对系统级编程来说是非常有用的，甚至是必需的。

**代码**：show_bytes.c

运行 show_bytes.c 编译后文件 show_bytes，可以观察到，尽管浮点型和整数数据对应的数值一样（如均为 12345），但是它们有截
然不同的字节模式：整型为`0x00003039`，而浮点型为`0x4640E400`。一般而言，这两种格式使用不同的编码方法。如果将这两个十六
进制模式扩展为二进制模式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列，用一串星号标记出来：

```
   0   0   0   0   3   0   3   9
00000000000000000011000000111001
                   *************
             4   6   4   0   E   4   0   0
          01000110010000001110010000000000
```

>> 表示字符串

C 语言中字符串被编码为一个以 null（其值为 0）字符结尾的字符数组。

>> 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此
二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来
帮助调试的辅助表以外。

>> 布尔代数简介

二进制是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 的研究已经演化出了丰富的数学知识体系。这起源于 1850 年 前
后乔治布尔的工作，因此也称为 **布尔代数(Boolean algebra)**。布尔注意到通过将逻辑值 TRUE 和 FALSE 编码为二进制值 1 和 0，
能够设计出一种代数，以研究逻辑推理的基本原则。

布尔运算`~`对应于逻辑运算`NOT`；
布尔运算`&`对应于逻辑运算`AND`；
布尔运算`|`对应于逻辑运算`OR`；
布尔运算`^`对应于逻辑运算`异或`；

我们可以将上述 4 个布尔运算扩展到 **位向量** 的运算，位向量就是固定长度为 ß、由 0 和 1 组成的串。位向量的运算可以定义成
参数的每个对应元素之间的运算。举个例子，假设 ß = 4，参数 a = [0110], b = [1100]。那么 4 种运算 a&b、a|b、a^b、~b 分别
得到以下结果：

```
  0110     0110     0110
& 1100   | 1100   ^ 1100   ~ 1100
  ————     ————     ————     ————
  0100     1110     1010     0011 
```

>> C 语言中的位级运算

C 语言的一个很有用的的特性就是它支持按位布尔运算。事实上，在布尔运算中使用的那些符号就是 C 语言所使用的：`|`就是`OR（或）`，
`&`就是`AND（与）`，`~`就是`NOT（取反）`，而`^`就是`EXCLUSIVE-OR（异或）`。这些运算能运用到任何"整型"的数据类型上。

```
// 对于任一位向量 a，有 a^a = 0。应用这一属性，考虑下面的程序：
void inplace_swap(int *x, int *y)
{
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}

/*
正如程序名字所暗示的那样，这个过程的效果是交换指针变量 x 和 y 所指向的存储位置处存放的值。注意，与通常的交换两个数值的技术不
一样，当移动一个值时，我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优势，它仅仅是一个智力游戏。
*/

```

位级运算的一个常见用法就是实现 **掩码** 运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

>> C 语言中的逻辑运算

C 语言还提供了一组逻辑运算符`||`、`&&`和`!`，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，
但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。

逻辑运算符`&&`和`||`与它们对应的位级运算`&`和`|`之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑
运算符就不会对第二个参数求值。

>> C 语言中的移位运算

C 语言还提供了一组 **移位** 运算，向左或者向右移动位模式。C 表达式`x<<k`，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。

有一个相应的右移运算`x>>k`，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：`逻辑右移`和`算术右移`。逻辑右移在左端补 k 个 0。
算术右移是在左端补 k 个最高有效位的值，这种做法看上去可能有点奇特，但是它对有符号整数数据的运算非常有用。

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移
形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种
右移。另一方面，对于无符号数，右移必须是逻辑的。

**与移位运算有关的操作符优先级问题**：加减法优先级比移位运算要高。所以`1<<2+3<<4`等价于`1<<(2+3)<<4`。


> 整数表示

>> 整形数据类型

C 语言支持多种 **整型** 数据类型——表示有限范围的整数。C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。

>> 无符号数的编码

无符号数编码的唯一性。

>> 补码编码

对于许多应用，我们还希望表示负值。最常见的有符号数的计算机表示方式就是 **补码(two's-complement)** 形式。在这个定义中，将字的最高有效位
解释为 **负权(negative weight)**。最高有效位也称为 **符号位**。符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负。

补码编码的唯一性。

