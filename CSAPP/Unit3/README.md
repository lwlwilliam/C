### 程序的机器级表示

计算机执行 **机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的
规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C 语言编译器以 **汇编代码** 的形式产生输出，汇编代码是机
器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用 **汇编器** 和 **链接器**，根据汇编代码生成可执行的机器代码。

用高级语言编写的程序最大优点是可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。那么为什么还要花时间学习机器代码？即
使编译器承担了生成汇编代码的大部分工作，但能够阅读和理解汇编代码仍是一项很重要的技能。通过阅读这些汇编代码，我们能够理解编译器的优化能力，
并分析代码中隐含的低效率。也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例如，用线程包写迸发程序时，了解不同的线
程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的。另外，程序遭受攻击
（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的
控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。

源代码与对应的汇编代码的关系通常不太容易理解——就像要拼出的拼图与盒子上图片的设计不太一样。这是一种 **逆向工程(reverse engineering)**
——通过研究系统和逆向工作，来试图了解系统的创建过程。

> 程序编码

假设一个 C 程序，有两个文件 p1.c 和 p2.c。使用 Unix 命令行编译这些代码：

```
linux> gcc -Og -o p p1.c p2.c
```

命令 gcc 指的就是 GCC C 编译器。选项`-Og`告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会
严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们使用`-Og`优化作为学习工具，然后当我们增加优化级别时，再看会发
生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项`-O1`或`-O2`指定）被认为是较好的选择。

实际上 gcc 命令调用了一整套的程序，将源代码转化成可执行代码。首先，C **预处理器** 扩展源代码，插入所有用`#include`命令指定的文件，并扩
展所有用`#defined`声明指定的宏。其次，**编译器** 产生两个源文件的汇编代码，名字分别为`p1.s`和`p2.s`。接下来，**汇编器** 会将汇编代码
转化成二进制 **目标代码** 文件`p1.o`和`p2.o`。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最
后，**链接器** 将两个目标代码文件与实现库函数（例如 printf）的代码合并，并产生最终的可执行代码文件`p`（由命令行指示符`-o p`指定的）。
可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

>> 机器级代码

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是由 **指令集
体系结构或指令集架构(Instruction Set Architecture, ISA)** 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指
令对状态的影响。第二利抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多
个硬件存储器和操作系统软件组合起来。

x86-64 的机器代码和原始和 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：
* `程序计数器`（通常称为"PC"，在 x86-64 中用 %rip 表示）给出将要执行的下一条指令在内存中的地址；
* `整数寄存器文件`包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 C 语言的指针）或整数数据。有的寄存器被用来记
  录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值；
* `条件码寄存器`保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如用来实现 if 和 while 语句；
* 一组`向量寄存器`可以存放一个或多个整数或浮点数值；

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc 库
函数分配的）。程序内存用虚拟地址来寻址。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

>> 代码示例

假设定了一个 C 语言代码文件 mstore.c，在命令行上使用"-S"选项，生成汇编代码：

```
linux> gcc -Og -S mstore.c
```

这会使 GCC 运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。汇编
代码文件包含各种声明，包括下面几行：

```
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    ret
```

上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq 指令表示应该将寄存器 %rbx 的内容压入程序栈中。这段代码已经除去了所有关于局部
变量名或数据类型的信息。

如果使用"-c"命令行选项，GCC 会编译并汇编该代码：

```
linux> gcc -Og -c mstore.c
```

就会产生目标代码文件 mstore.o，它是二进制格式的，所以无法直接查看。1368 字节的文件 mstore.o 中有一段 14 字节的序列，它的十六进制表示
为：

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指
令的源代码几乎一无所知。

要查看机器代码文件的内容，有一类称为 **反编译器(disassembler)** 的程序非常有用。
