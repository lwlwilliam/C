### 指针变量

指针变量是一种存放地址的特殊变量，其特殊性表现在类型和值上。从变量角度讲，指针变量也具有变量的要素：

1. 指针变量的命名，与一般变量命名相同，遵循C语言的命名规则；

2. 指针变量的类型，是指针变量所指向的变量的类型，而不是自身的类型；

> 定义指针变量

定义指针变量的一般形式：类型名 * 指针变量名，如：`int * point_1, * point_2`。

注意：指针变量前面的"*"表示该变量的类型为指针型变量。指针变量名是point_1和point_2，而不是*point_1和*point_2。


> 引用指针变量

在引用指针变量时，有以下3种情况：

1. 给指针变量赋值，如：`p = &a; // 把a的地址赋给指针变量p`，指针变量p的值是变量a的地址，p指向a；

2. 引用指针变量指向的变量，如果已执行`p = &a`，即指针变量p指向了整型变量a，则`printf("%d", *p);`，其作用是以整数形式输出指针变量p所指向的变量的值，即变量a的值；如果有以下赋值语句`*p = 1;`，表示将整数1赋给p当前所指向的变量，如果p指向变量a，则相当于把1赋给a，即`a = 1`；

3. 引用指针变量的值，如`printf("%o", p);`，作用就是以八进制数形式输出指针变量p的值，如果p指向了a，就是输出a的地址，即&a。


> 通过指针引用数组

可以用一个指针变量指向一个数组元素。

```
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *p;
p = &a[0];
```

以上是使指针变量p指向a数组的第0个元素。

在C语言中，数组名（不包括形参数组名，形参数组并不占据实际的内存单元）代表数组中首元素（即序号为0的元素）的地址。因此下面两个语句等价：

```
p = &a[0];	// p的值是a[0]的地址
p = a;	// p的值是数组a首元素（即a[0]）的地址
```

注意：数组名不代表整个数组，只代表数组首元素的地址。上述`p = a;`的作用是把a数组的首元素的地直赋给指针变量p，而不是把数组a各元素的值赋给p。


> 引用数组元素时指针的运算

在指针指向数组元素时，可以对指针进行以下运算：

1. 加减一个整数，如`p + 1;`或者`p - 1;`；

2. 自加运算，如`p ++;`或者`++ p;`；

3. 自减运算，如`p --;`或者`-- p;`；

分别说明如下：
1. 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素。注意：执行p+1时并不是 将p的值（地址）简单地加1，而是加上一个数组元素所占用的字节数。例如：数组元素是float型，每一个元素占4个节字，则p+1意味着使p的值加4个字节，以使它指向下一个元素。p+1所代表的地址实际上是p+1*d，d是一个数组元素所占的字节数。若p的值是2000，则p+1的值不是2001而是2004。

2. 如果p的初值为&a[0]，岀p+1和a+1就是数组元素a[i]的地址，或者说，他们指向a数组序号为i的元素。

3. *(p+i)和*(a+i)是p+i或a+i所指向的元素，即a[i]。例如*(p+5)和*(a+5)就是a[5]，三者等价。

根据以上叙述，引用一个数组元素，可以用下面两种方法：

1. 下标法，如a[i]；

2. 指针法，如*(a+1)或*(p+i)。其中a是数组名，p是指向数组元素的指针变量，其初值p=a;

数组名a代表数组首元素的地址，它是一个指针型常量，它的值在程序运行期间是固定不变的。既然a是常量，所以a++是无法实现的。

数组名a代表数组首元素的地址，它是一个指针型常量，它的值在程序运行期间是固定不变的。既然a是常量，所以a++是无法实现的。

```
int main()
{
	int *p, i, a[10];
	p = a;
	printf("please enter 10 integer number: ");
	for (i = 0; i < 10; i ++) {
		scanf("%d", p ++);
	}
	for (i = 0; i < 10; i ++, p ++) {
		printf("%d\t", *p);
	}
	printf("\n");
	return 0;
}
```

以上程序是有问题的，指针变量p的初始值为a数组首元素的地址，但经过第一个for循环读入数据后，p已指向a数组的末尾。因此，在执行第2个for循环时，p的起始值不是&a[0]了，而是a+10。由于执行第2个for循环时，每次要执行p++，因此p指向的是a数组下面的10个存储单元。解决方法就是在第2个循环之前加一个赋值语句`p=a`，使p的初始值重新等于&a[0]。


> 用数组名做函数参数

实参数组名代表该数组首元素的地址，而形参是用来接收从实参传递过来的数组首元素地址的。因此，形参应该是一个指针变量。实际上C编译系统是将形参数组名作为指针变量来处理的。例如`fun(int arr[], int n)`在程序编译时是将arr按指针变量处理的，相当于将函数fun的首部写成`fun(int *arr, int n)`，上面两种写法是等价的。在该函数被调用时，系统会在fun函数中建一个指针变量arr，用来存放从主调函数传递过来的实参数组首元素的地址。

当arr接收了实参数组的首元素地址后，arr就指向实参数组首元素，也就是指向array[0]。因此*arr就是array[0]，*(arr+1)就是array[1]。可以这样来理解，在函数调用期间，形参数组从实参数组那里得到起始地址，因此形参数组与实参数组共占用一段内存单元，在调用函数期间，如果改变了形参数组的值，也就是改变了实参数组的值。


如果有一个实参数组，要想在函数中改变数组中的元素的值，实参和形参的对应关系有以下4种情况：
1. 形参和实参都用数组名：

```
int main()
{
	int a[10];
	.
	.
	.
	f(a, 10);
}

int f(int x[], int n)
{
	.
	.
	.
}
```

由于形参数组名x接收了实参数组首元素a[0]的地址，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元。

2. 实参用数组名，形参用指针变量：

```
int main()
{
	int a[10];
	.
	.
	.
	f(a, 10);
}

void f(int *x, int n)
{
	.
	.
	.
}
```

实参a为数组名，形参x为int *型的指针变量，调用函数开始后，形参x指向a[0]，即x=&a[0]，通过x值的改变，可以指向a数组的任一元素。

3. 实参形参都用指针变量：

```
int main()
{
	int a[10], *p = a;
	.
	.
	.
	f(p, 10);
	.
	.
	.
}

void f(int *x, int n)
{
	.
	.
	.
}
```

4. 实参为指针变量，形参为数组名：

```
int main()
{
	int a[10], *p = a;
	.
	.
	.
	f(p, 10);
}

void f(int x[], int n)
{
	.
	.
	.
}
```

实参p为指针变量，它指向a[0]。形参为数组名x，编译系统把x作为指针变量处理，将a[0]的地址传给形参x，使x也指向a[0]。也可以理解为形参数组x和a数组共用同一段内存单元。在执行过程中可以使x[i]的值变化，而x[i]就是a[i]。
